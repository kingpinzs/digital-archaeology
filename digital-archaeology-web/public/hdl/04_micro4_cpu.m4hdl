# ============================================
# Micro4 CPU - Complete Implementation
# ============================================
# A minimal 4-bit CPU built from logic gates
#
# Architecture:
#   - 4-bit data bus
#   - 8-bit address bus (256 nibble locations)
#   - Accumulator-based (single working register)
#   - 8 instructions

# ============================================
# CPU Block Diagram
# ============================================
#
#  +------------------------------------------------------------------+
#  |                         MICRO4 CPU                               |
#  |                                                                  |
#  |   +--------+    +--------+    +--------+                        |
#  |   |   PC   |    |   IR   |    |   A    |                        |
#  |   | 8-bit  |    | 8-bit  |    | 4-bit  |                        |
#  |   +---+----+    +---+----+    +---+----+                        |
#  |       |             |             |                              |
#  |       v             v             v                              |
#  |   +--------+    +--------+    +--------+                        |
#  |   |  MAR   |    | DECODE |    |  ALU   |                        |
#  |   | 8-bit  |    |        |    | 4-bit  |                        |
#  |   +---+----+    +---+----+    +---+----+                        |
#  |       |             |             |                              |
#  |       v             v             v                              |
#  |   +--------+    +--------+    +--------+                        |
#  |   |  MDR   |<-->|CONTROL |    |   Z    |                        |
#  |   | 4-bit  |    | UNIT   |    |  flag  |                        |
#  |   +---+----+    +--------+    +--------+                        |
#  |       |                                                          |
#  +-------+----------------------------------------------------------+
#          |
#          v
#      MEMORY BUS

# ============================================
# Registers
# ============================================

# Program Counter (8-bit)
wire [7:0] pc;
wire [7:0] pc_next;
wire pc_load;       # Load new value (for jumps)
wire pc_inc;        # Increment by 1 or 2
wire pc_inc2;       # Increment by 2 (for 2-byte instructions)
wire clk;
wire rst;

# Accumulator (4-bit)
wire [3:0] acc;
wire [3:0] acc_next;
wire acc_load;

# Zero Flag
wire z_flag;
wire z_flag_next;
wire z_load;

# Instruction Register (8-bit = opcode + operand nibbles)
wire [7:0] ir;
wire ir_load;

# Memory Address Register (8-bit)
wire [7:0] mar;
wire mar_load;

# Memory Data Register (4-bit)
wire [3:0] mdr;
wire mdr_load;

# ============================================
# Instruction Decoder
# ============================================
# Opcode is upper nibble of IR: IR[7:4]
#
# Opcodes:
#   0000 = HLT
#   0001 = LDA addr
#   0010 = STA addr
#   0011 = ADD addr
#   0100 = SUB addr
#   0101 = JMP addr
#   0110 = JZ addr
#   0111 = LDI imm

wire [3:0] opcode;
wire is_hlt;
wire is_lda;
wire is_sta;
wire is_add;
wire is_sub;
wire is_jmp;
wire is_jz;
wire is_ldi;

# Extract opcode from IR
buf DEC_OP0 (input: ir[4], output: opcode[0]);
buf DEC_OP1 (input: ir[5], output: opcode[1]);
buf DEC_OP2 (input: ir[6], output: opcode[2]);
buf DEC_OP3 (input: ir[7], output: opcode[3]);

# Decode individual instructions
# HLT: 0000
wire op0n;
wire op1n;
wire op2n;
wire op3n;
not DEC_NOT0 (input: opcode[0], output: op0n);
not DEC_NOT1 (input: opcode[1], output: op1n);
not DEC_NOT2 (input: opcode[2], output: op2n);
not DEC_NOT3 (input: opcode[3], output: op3n);

# is_hlt = !op3 & !op2 & !op1 & !op0
wire hlt_t1;
wire hlt_t2;
and DEC_HLT1 (input: op3n op2n, output: hlt_t1);
and DEC_HLT2 (input: op1n op0n, output: hlt_t2);
and DEC_HLT3 (input: hlt_t1 hlt_t2, output: is_hlt);

# is_lda = !op3 & !op2 & !op1 & op0  (0001)
wire lda_t;
and DEC_LDA1 (input: hlt_t1 op1n, output: lda_t);
and DEC_LDA2 (input: lda_t opcode[0], output: is_lda);

# is_sta = !op3 & !op2 & op1 & !op0  (0010)
wire sta_t1;
wire sta_t2;
and DEC_STA1 (input: op3n op2n, output: sta_t1);
and DEC_STA2 (input: opcode[1] op0n, output: sta_t2);
and DEC_STA3 (input: sta_t1 sta_t2, output: is_sta);

# is_add = !op3 & !op2 & op1 & op0  (0011)
wire add_t;
and DEC_ADD1 (input: opcode[1] opcode[0], output: add_t);
and DEC_ADD2 (input: sta_t1 add_t, output: is_add);

# is_sub = !op3 & op2 & !op1 & !op0  (0100)
wire sub_t1;
wire sub_t2;
and DEC_SUB1 (input: op3n opcode[2], output: sub_t1);
and DEC_SUB2 (input: op1n op0n, output: sub_t2);
and DEC_SUB3 (input: sub_t1 sub_t2, output: is_sub);

# is_jmp = !op3 & op2 & !op1 & op0  (0101)
wire jmp_t;
and DEC_JMP1 (input: op1n opcode[0], output: jmp_t);
and DEC_JMP2 (input: sub_t1 jmp_t, output: is_jmp);

# is_jz = !op3 & op2 & op1 & !op0  (0110)
wire jz_t;
and DEC_JZ1 (input: opcode[1] op0n, output: jz_t);
and DEC_JZ2 (input: sub_t1 jz_t, output: is_jz);

# is_ldi = !op3 & op2 & op1 & op0  (0111)
wire ldi_t;
and DEC_LDI1 (input: opcode[1] opcode[0], output: ldi_t);
and DEC_LDI2 (input: sub_t1 ldi_t, output: is_ldi);

# ============================================
# ALU Connections
# ============================================
# ALU inputs:
#   A = Accumulator
#   B = MDR (from memory)
#   OP[0] = 1 for SUB, 0 for ADD
#   OP[1] = reserved

wire [3:0] alu_a_in;
wire [3:0] alu_b_in;
wire alu_op0;
wire [3:0] alu_result;
wire alu_zero;
wire alu_carry;

# Connect accumulator to ALU input A
buf ALU_A0 (input: acc[0], output: alu_a_in[0]);
buf ALU_A1 (input: acc[1], output: alu_a_in[1]);
buf ALU_A2 (input: acc[2], output: alu_a_in[2]);
buf ALU_A3 (input: acc[3], output: alu_a_in[3]);

# Connect MDR to ALU input B
buf ALU_B0 (input: mdr[0], output: alu_b_in[0]);
buf ALU_B1 (input: mdr[1], output: alu_b_in[1]);
buf ALU_B2 (input: mdr[2], output: alu_b_in[2]);
buf ALU_B3 (input: mdr[3], output: alu_b_in[3]);

# ALU operation: SUB if is_sub, else ADD
buf ALU_OP (input: is_sub, output: alu_op0);

# (ALU implementation would go here - using the gates from 03_alu.m4hdl)

# ============================================
# Control Unit State Machine
# ============================================
# States:
#   S0: FETCH1 - MAR <- PC, initiate memory read
#   S1: FETCH2 - IR <- MDR (high nibble)
#   S2: FETCH3 - IR <- IR | MDR (low nibble), PC++
#   S3: DECODE - Decode opcode, branch to execute
#   S4: FETCH_ADDR1 - MAR <- PC (for 2-byte instructions)
#   S5: FETCH_ADDR2 - addr_reg <- MDR, PC++
#   S6: EXECUTE - Execute the instruction
#   S7: WRITEBACK - Write result if needed
#
# For simplicity, the control unit generates signals based on
# the current state and opcode.

wire [2:0] state;
wire [2:0] state_next;

# State register (3-bit)
dff STATE0 (input: state_next[0] clk, output: state[0]);
dff STATE1 (input: state_next[1] clk, output: state[1]);
dff STATE2 (input: state_next[2] clk, output: state[2]);

# ============================================
# Control Signals (generated by control unit)
# ============================================
# These would be generated by a PLA or ROM based on
# the current state and opcode.

wire halt;          # Stop the clock
wire mem_read;      # Read from memory
wire mem_write;     # Write to memory
# wire pc_inc;      # Increment PC (declared above)
# wire pc_load;     # Load PC from address (declared above)
# wire ir_load;     # Load instruction register (declared above)
# wire mar_load;    # Load memory address register (declared above)
# wire acc_load;    # Load accumulator (declared above)
# wire z_load;      # Load zero flag (declared above)
wire alu_to_acc;    # ALU result goes to accumulator
wire mdr_to_acc;    # MDR goes to accumulator (for LDA)
wire imm_to_acc;    # Immediate value goes to accumulator (for LDI)

# ============================================
# Memory Interface
# ============================================
wire [7:0] mem_addr;    # Address to memory
wire [3:0] mem_data_in; # Data from memory
wire [3:0] mem_data_out;# Data to memory

# MAR drives memory address
buf MEM_ADDR0 (input: mar[0], output: mem_addr[0]);
buf MEM_ADDR1 (input: mar[1], output: mem_addr[1]);
buf MEM_ADDR2 (input: mar[2], output: mem_addr[2]);
buf MEM_ADDR3 (input: mar[3], output: mem_addr[3]);
buf MEM_ADDR4 (input: mar[4], output: mem_addr[4]);
buf MEM_ADDR5 (input: mar[5], output: mem_addr[5]);
buf MEM_ADDR6 (input: mar[6], output: mem_addr[6]);
buf MEM_ADDR7 (input: mar[7], output: mem_addr[7]);

# MDR receives data from memory (directly assigned in simulation)
# MDR drives data to memory for writes
buf MEM_DOUT0 (input: acc[0], output: mem_data_out[0]);
buf MEM_DOUT1 (input: acc[1], output: mem_data_out[1]);
buf MEM_DOUT2 (input: acc[2], output: mem_data_out[2]);
buf MEM_DOUT3 (input: acc[3], output: mem_data_out[3]);

# ============================================
# Component Count Summary
# ============================================
#
# Registers:
#   PC (8-bit):     8 DFFs = ~320 transistors
#   Accumulator:    4 DFFs = ~160 transistors
#   Zero Flag:      1 DFF  = ~40 transistors
#   IR (8-bit):     8 DFFs = ~320 transistors
#   MAR (8-bit):    8 DFFs = ~320 transistors
#   MDR (4-bit):    4 DFFs = ~160 transistors
#   State (3-bit):  3 DFFs = ~120 transistors
#
# ALU:              ~200 transistors
#
# Decoder:          ~50 transistors
#
# Control Logic:    ~200 transistors (estimate)
#
# Multiplexers:     ~300 transistors (estimate)
#
# TOTAL: ~2,200 transistors
# (Intel 4004 had ~2,300 transistors - we're close!)

# ============================================
# Additional Instruction Decoders (8-F)
# ============================================

# is_and = op3 & !op2 & !op1 & !op0  (1000)
wire and_t1;
and DEC_AND1 (input: opcode[3] op2n, output: and_t1);
and DEC_AND2 (input: and_t1 hlt_t2, output: is_and);
wire is_and;

# is_or = op3 & !op2 & !op1 & op0  (1001)
wire is_or;
wire or_t;
and DEC_OR1 (input: op1n opcode[0], output: or_t);
and DEC_OR2 (input: and_t1 or_t, output: is_or);

# is_xor = op3 & !op2 & op1 & !op0  (1010)
wire is_xor;
wire xor_t;
and DEC_XOR1 (input: opcode[1] op0n, output: xor_t);
and DEC_XOR2 (input: and_t1 xor_t, output: is_xor);

# is_not = op3 & !op2 & op1 & op0  (1011)
wire is_not;
wire not_t;
and DEC_NOT2 (input: opcode[1] opcode[0], output: not_t);
and DEC_NOT3 (input: and_t1 not_t, output: is_not);

# is_shl = op3 & op2 & !op1 & !op0  (1100)
wire is_shl;
wire shl_t1;
and DEC_SHL1 (input: opcode[3] opcode[2], output: shl_t1);
and DEC_SHL2 (input: shl_t1 hlt_t2, output: is_shl);

# is_shr = op3 & op2 & !op1 & op0  (1101)
wire is_shr;
wire shr_t;
and DEC_SHR1 (input: op1n opcode[0], output: shr_t);
and DEC_SHR2 (input: shl_t1 shr_t, output: is_shr);

# is_inc = op3 & op2 & op1 & !op0  (1110)
wire is_inc;
wire inc_t;
and DEC_INC1 (input: opcode[1] op0n, output: inc_t);
and DEC_INC2 (input: shl_t1 inc_t, output: is_inc);

# is_dec = op3 & op2 & op1 & op0  (1111)
wire is_dec;
wire dec_t;
and DEC_DEC1 (input: opcode[1] opcode[0], output: dec_t);
and DEC_DEC2 (input: shl_t1 dec_t, output: is_dec);

# ============================================
# Instruction Categories
# ============================================
# Single-byte instructions (no address fetch needed):
#   HLT, LDI, NOT, SHL, SHR, INC, DEC
# Two-byte instructions (need address fetch):
#   LDA, STA, ADD, SUB, JMP, JZ, AND, OR, XOR

# is_single_byte = HLT | LDI | NOT | SHL | SHR | INC | DEC
wire is_single_byte;
wire single_t1;
wire single_t2;
wire single_t3;
or CAT_SB1 (input: is_hlt is_ldi, output: single_t1);
or CAT_SB2 (input: is_not is_shl, output: single_t2);
or CAT_SB3 (input: is_shr is_inc, output: single_t3);
wire single_t4;
wire single_t5;
or CAT_SB4 (input: single_t1 single_t2, output: single_t4);
or CAT_SB5 (input: single_t3 is_dec, output: single_t5);
or CAT_SB6 (input: single_t4 single_t5, output: is_single_byte);

# is_mem_read = LDA | ADD | SUB | AND | OR | XOR (read memory at addr)
wire is_mem_read_op;
wire mem_rd_t1;
wire mem_rd_t2;
wire mem_rd_t3;
or CAT_MR1 (input: is_lda is_add, output: mem_rd_t1);
or CAT_MR2 (input: is_sub is_and, output: mem_rd_t2);
or CAT_MR3 (input: is_or is_xor, output: mem_rd_t3);
wire mem_rd_t4;
or CAT_MR4 (input: mem_rd_t1 mem_rd_t2, output: mem_rd_t4);
or CAT_MR5 (input: mem_rd_t4 mem_rd_t3, output: is_mem_read_op);

# is_alu_op = ADD | SUB | AND | OR | XOR | NOT | SHL | SHR | INC | DEC
wire is_alu_op;
wire alu_t1;
wire alu_t2;
wire alu_t3;
wire alu_t4;
wire alu_t5;
or CAT_ALU1 (input: is_add is_sub, output: alu_t1);
or CAT_ALU2 (input: is_and is_or, output: alu_t2);
or CAT_ALU3 (input: is_xor is_not, output: alu_t3);
or CAT_ALU4 (input: is_shl is_shr, output: alu_t4);
or CAT_ALU5 (input: is_inc is_dec, output: alu_t5);
wire alu_t6;
wire alu_t7;
or CAT_ALU6 (input: alu_t1 alu_t2, output: alu_t6);
or CAT_ALU7 (input: alu_t3 alu_t4, output: alu_t7);
wire alu_t8;
or CAT_ALU8 (input: alu_t6 alu_t7, output: alu_t8);
or CAT_ALU9 (input: alu_t8 alu_t5, output: is_alu_op);

# is_jump_op = JMP | JZ
wire is_jump_op;
or CAT_JMP (input: is_jmp is_jz, output: is_jump_op);

# ============================================
# State Machine Implementation
# ============================================
# Simplified states:
#   S0 (000): FETCH - Load PC into MAR, read memory
#   S1 (001): DECODE - IR loaded, decode opcode
#   S2 (010): FETCH_ADDR - Fetch 2nd byte (address)
#   S3 (011): EXECUTE - Read memory if needed
#   S4 (100): WRITEBACK - Write result, update PC

wire s0;
wire s1;
wire s2;
wire sn0;
wire sn1;
wire sn2;
not STATE_N0 (input: state[0], output: sn0);
not STATE_N1 (input: state[1], output: sn1);
not STATE_N2 (input: state[2], output: sn2);

# Decode current state
wire is_s0;
wire is_s1;
wire is_s2;
wire is_s3;
wire is_s4;
wire st_t1;
wire st_t2;
wire st_t3;
# S0 = !s2 & !s1 & !s0
and STATE_IS0_1 (input: sn2 sn1, output: st_t1);
and STATE_IS0_2 (input: st_t1 sn0, output: is_s0);
# S1 = !s2 & !s1 & s0
and STATE_IS1 (input: st_t1 state[0], output: is_s1);
# S2 = !s2 & s1 & !s0
and STATE_IS2_1 (input: sn2 state[1], output: st_t2);
and STATE_IS2_2 (input: st_t2 sn0, output: is_s2);
# S3 = !s2 & s1 & s0
and STATE_IS3 (input: st_t2 state[0], output: is_s3);
# S4 = s2 & !s1 & !s0
and STATE_IS4_1 (input: state[2] sn1, output: st_t3);
and STATE_IS4_2 (input: st_t3 sn0, output: is_s4);

# ============================================
# State Transitions
# ============================================
# From S0 (FETCH): always go to S1 (DECODE)
# From S1 (DECODE):
#   - If single-byte: go to S4 (WRITEBACK)
#   - Else: go to S2 (FETCH_ADDR)
# From S2 (FETCH_ADDR):
#   - If jump: go to S4 (WRITEBACK)
#   - Else: go to S3 (EXECUTE)
# From S3 (EXECUTE): go to S4 (WRITEBACK)
# From S4 (WRITEBACK): go to S0 (FETCH) unless HLT

# next_state[0]:
#   1 if (is_s0) OR (is_s2 & !is_jump_op)
wire ns0_t1;
wire ns0_t2;
wire is_jump_n;
not NS0_NOT (input: is_jump_op, output: is_jump_n);
and NS0_AND (input: is_s2 is_jump_n, output: ns0_t1);
or NS0_OR (input: is_s0 ns0_t1, output: ns0_t2);
# Also 1 if is_s1 & is_single_byte (S1->S4: 100, but we need 011->100)
# Wait, S4=100, so from S1 going to S4: state_next = 100
# Actually let me re-think the state encoding...

# Simpler approach: encode states differently
# S0=000, S1=001, S2=010, S3=011, S4=100
# Transitions:
#   000 -> 001 (always)
#   001 -> 100 (if single-byte) or 010 (if two-byte)
#   010 -> 100 (if jump) or 011 (if mem op)
#   011 -> 100 (always)
#   100 -> 000 (unless HLT)

# state_next[2]:
#   1 if going to S4 (100):
#     (is_s1 & is_single_byte) OR
#     (is_s2 & is_jump_op) OR
#     is_s3
wire ns2_t1;
wire ns2_t2;
wire ns2_t3;
and NS2_T1 (input: is_s1 is_single_byte, output: ns2_t1);
and NS2_T2 (input: is_s2 is_jump_op, output: ns2_t2);
or NS2_OR1 (input: ns2_t1 ns2_t2, output: ns2_t3);
or NS2_OR2 (input: ns2_t3 is_s3, output: state_next[2]);

# state_next[1]:
#   1 if going to S2 (010) or S3 (011):
#     (is_s1 & !is_single_byte) OR
#     (is_s2 & !is_jump_op)
wire ns1_t1;
wire ns1_t2;
wire is_single_n;
not NS1_NOT (input: is_single_byte, output: is_single_n);
and NS1_T1 (input: is_s1 is_single_n, output: ns1_t1);
and NS1_T2 (input: is_s2 is_jump_n, output: ns1_t2);
or NS1_OR (input: ns1_t1 ns1_t2, output: state_next[1]);

# state_next[0]:
#   1 if going to S1 (001) or S3 (011):
#     is_s0 OR (is_s2 & !is_jump_op)
or NS0_FINAL (input: is_s0 ns1_t2, output: state_next[0]);

# ============================================
# Control Signal Generation
# ============================================

# halt = is_s4 & is_hlt
and CTRL_HALT (input: is_s4 is_hlt, output: halt);

# mem_read = is_s0 | is_s2 | (is_s3 & is_mem_read_op)
wire mr_t1;
and CTRL_MR1 (input: is_s3 is_mem_read_op, output: mr_t1);
wire mr_t2;
or CTRL_MR2 (input: is_s0 is_s2, output: mr_t2);
or CTRL_MR3 (input: mr_t2 mr_t1, output: mem_read);

# mem_write = is_s3 & is_sta
and CTRL_MW (input: is_s3 is_sta, output: mem_write);

# pc_inc = is_s0 | is_s2 (increment PC after fetch)
or CTRL_PCINC (input: is_s0 is_s2, output: pc_inc);

# pc_load = is_s4 & is_jmp | (is_s4 & is_jz & z_flag)
wire pc_ld_t1;
wire pc_ld_t2;
wire pc_ld_t3;
and CTRL_PCLD1 (input: is_s4 is_jmp, output: pc_ld_t1);
and CTRL_PCLD2 (input: is_s4 is_jz, output: pc_ld_t2);
and CTRL_PCLD3 (input: pc_ld_t2 z_flag, output: pc_ld_t3);
or CTRL_PCLD4 (input: pc_ld_t1 pc_ld_t3, output: pc_load);

# ir_load = is_s0 (load instruction register during fetch)
buf CTRL_IRLD (input: is_s0, output: ir_load);

# mar_load = is_s0 | is_s2 | is_s3
wire mar_t1;
or CTRL_MARLD1 (input: is_s0 is_s2, output: mar_t1);
or CTRL_MARLD2 (input: mar_t1 is_s3, output: mar_load);

# acc_load = is_s4 & (is_lda | is_ldi | is_alu_op)
wire acc_ld_t1;
wire acc_ld_t2;
or CTRL_ACCLD1 (input: is_lda is_ldi, output: acc_ld_t1);
or CTRL_ACCLD2 (input: acc_ld_t1 is_alu_op, output: acc_ld_t2);
and CTRL_ACCLD3 (input: is_s4 acc_ld_t2, output: acc_load);

# z_load = acc_load (update zero flag when accumulator changes)
buf CTRL_ZLD (input: acc_load, output: z_load);

# alu_to_acc = is_s4 & is_alu_op
and CTRL_ALU2ACC (input: is_s4 is_alu_op, output: alu_to_acc);

# mdr_to_acc = is_s4 & is_lda
and CTRL_MDR2ACC (input: is_s4 is_lda, output: mdr_to_acc);

# imm_to_acc = is_s4 & is_ldi
and CTRL_IMM2ACC (input: is_s4 is_ldi, output: imm_to_acc);

# mdr_load = is_s3 & is_mem_read_op
and CTRL_MDRLD (input: is_s3 is_mem_read_op, output: mdr_load);

# ============================================
# ALU Operation Selection (4-bit)
# ============================================
# ALU op encoding:
#   0000 = ADD
#   0001 = SUB
#   0010 = AND
#   0011 = OR
#   0100 = XOR
#   0101 = NOT
#   0110 = SHL
#   0111 = SHR
#   1000 = INC (A + 1)
#   1001 = DEC (A - 1)

wire [3:0] alu_op;

# alu_op[0] = SUB | OR | NOT | SHR | DEC
wire aluop0_t1;
wire aluop0_t2;
or ALUOP0_1 (input: is_sub is_or, output: aluop0_t1);
or ALUOP0_2 (input: is_not is_shr, output: aluop0_t2);
wire aluop0_t3;
or ALUOP0_3 (input: aluop0_t1 aluop0_t2, output: aluop0_t3);
or ALUOP0_4 (input: aluop0_t3 is_dec, output: alu_op[0]);

# alu_op[1] = AND | OR | SHL | SHR
wire aluop1_t1;
or ALUOP1_1 (input: is_and is_or, output: aluop1_t1);
wire aluop1_t2;
or ALUOP1_2 (input: is_shl is_shr, output: aluop1_t2);
or ALUOP1_3 (input: aluop1_t1 aluop1_t2, output: alu_op[1]);

# alu_op[2] = XOR | NOT | SHL | SHR
wire aluop2_t1;
or ALUOP2_1 (input: is_xor is_not, output: aluop2_t1);
or ALUOP2_2 (input: aluop2_t1 aluop1_t2, output: alu_op[2]);

# alu_op[3] = INC | DEC
or ALUOP3 (input: is_inc is_dec, output: alu_op[3]);

# ============================================
# Register Updates (D Flip-Flops)
# ============================================

# PC Register (8-bit)
# pc_next = pc_load ? addr_reg : (pc_inc ? pc + 2 : pc)
# For simplicity, PC update handled by simulator

# Accumulator Register (4-bit)
# acc_next selected by mux: alu_result, mdr, or immediate
dff ACC0 (input: acc_next[0] clk, output: acc[0]);
dff ACC1 (input: acc_next[1] clk, output: acc[1]);
dff ACC2 (input: acc_next[2] clk, output: acc[2]);
dff ACC3 (input: acc_next[3] clk, output: acc[3]);

# Zero Flag Register
dff ZFLAG (input: z_flag_next clk, output: z_flag);

# IR Register (8-bit)
dff IR0 (input: mem_data_in[0] clk, output: ir[0]);
dff IR1 (input: mem_data_in[1] clk, output: ir[1]);
dff IR2 (input: mem_data_in[2] clk, output: ir[2]);
dff IR3 (input: mem_data_in[3] clk, output: ir[3]);
# (IR high nibble loaded from memory in second cycle)

# MAR Register (8-bit) - holds address for memory operations
dff MAR0 (input: mar_next[0] clk, output: mar[0]);
dff MAR1 (input: mar_next[1] clk, output: mar[1]);
dff MAR2 (input: mar_next[2] clk, output: mar[2]);
dff MAR3 (input: mar_next[3] clk, output: mar[3]);
dff MAR4 (input: mar_next[4] clk, output: mar[4]);
dff MAR5 (input: mar_next[5] clk, output: mar[5]);
dff MAR6 (input: mar_next[6] clk, output: mar[6]);
dff MAR7 (input: mar_next[7] clk, output: mar[7]);

wire [7:0] mar_next;

# PC Register (8-bit)
dff PC0 (input: pc_next[0] clk, output: pc[0]);
dff PC1 (input: pc_next[1] clk, output: pc[1]);
dff PC2 (input: pc_next[2] clk, output: pc[2]);
dff PC3 (input: pc_next[3] clk, output: pc[3]);
dff PC4 (input: pc_next[4] clk, output: pc[4]);
dff PC5 (input: pc_next[5] clk, output: pc[5]);
dff PC6 (input: pc_next[6] clk, output: pc[6]);
dff PC7 (input: pc_next[7] clk, output: pc[7]);

# ============================================
# Component Count Summary (Updated)
# ============================================
#
# Registers:
#   PC (8-bit):        8 DFFs = ~320 transistors
#   Accumulator:       4 DFFs = ~160 transistors
#   Zero Flag:         1 DFF  = ~40 transistors
#   IR (8-bit):        8 DFFs = ~320 transistors
#   MAR (8-bit):       8 DFFs = ~320 transistors
#   MDR (4-bit):       4 DFFs = ~160 transistors
#   State (3-bit):     3 DFFs = ~120 transistors
#
# ALU:                 ~200 transistors
#
# Decoder (16 ops):    ~100 transistors
#
# Control Logic:       ~300 transistors
#
# Multiplexers:        ~400 transistors
#
# TOTAL: ~2,440 transistors
# (Intel 4004 had ~2,300 transistors - very close!)
#
# Gate count: ~425 gates
# (AND, OR, NOT, XOR, MUX, DFF)
#
# ============================================
# Simulation Notes
# ============================================
#
# Clock speed estimation (for different technologies):
#
# Technology      | Gate Delay | Max Clock  | MIPS (est)
# ----------------|------------|------------|------------
# Relay (1940s)   | 10 ms      | ~10 Hz     | 0.000001
# RTL (1960s)     | 50 ns      | ~1 MHz     | 0.1
# TTL (1970s)     | 10 ns      | ~10 MHz    | 1
# NMOS (1980s)    | 5 ns       | ~20 MHz    | 2
# CMOS (1990s)    | 1 ns       | ~100 MHz   | 10
# Modern (2020s)  | 0.1 ns     | ~1 GHz     | 100
#
# Critical path: ~8-10 gate delays through ALU + control
# So realistic max clock = 1 / (10 * gate_delay)
#
