{
  "version": "1.0.0",
  "metadata": {
    "title": "Digital Archaeology",
    "author": "Digital Archaeology Team",
    "lastUpdated": "2026-01-24"
  },
  "acts": [
    {
      "id": "act-2",
      "number": 2,
      "title": "The Electronic Giants",
      "description": "The vacuum tube unlocked electronic speed‚Äîbut ENIAC, the first general-purpose electronic computer, filled a room and consumed enough power to dim the lights of Philadelphia. From hardwired programs to stored instructions, from military secrets to commercial products, the electronic giants would define what a computer could be.",
      "era": "1945 - 1955",
      "cpuStage": "vacuum",
      "chapters": [
        {
          "id": "chapter-2-1",
          "number": 1,
          "title": "The Firing Tables",
          "subtitle": "Moore School of Electrical Engineering, Philadelphia",
          "year": "1945",
          "scenes": [
            {
              "id": "scene-2-1-1",
              "type": "narrative",
              "setting": {
                "text": "Moore School of Electrical Engineering, University of Pennsylvania. Summer 1945. In a sealed room, eighteen thousand vacuum tubes glow orange. The air shimmers with heat. The noise is deafening. ENIAC‚Äîthe Electronic Numerical Integrator and Computer‚Äîis coming to life."
              },
              "narrative": [
                "You've been assigned to the ENIAC project as a junior technician. The machine sprawls across an entire room: forty panels, each eight feet tall, connected by miles of wiring. The heat output equals that of a small furnace.",
                "The purpose: calculate artillery firing tables. A single trajectory, computed by hand, takes a human 'computer' forty hours. ENIAC will do it in thirty seconds.",
                "But first, it has to work. And right now, tubes are failing faster than they can be replaced."
              ],
              "characters": [
                {
                  "avatar": "üë®‚Äçüî¨",
                  "name": "John Mauchly",
                  "title": "Principal Consultant, ENIAC Project",
                  "bio": "A physics professor who dreamed of electronic computation after working with weather data. Mauchly saw that electronic switching could revolutionize calculation. He proposed ENIAC to the Army, partnering with engineer Presper Eckert to build it.",
                  "stats": [
                    { "label": "Vision", "value": "Electronic computation for science" },
                    { "label": "Challenge", "value": "Convincing skeptics it would work" }
                  ]
                },
                {
                  "avatar": "üîß",
                  "name": "J. Presper Eckert",
                  "title": "Chief Engineer, ENIAC Project",
                  "bio": "The engineering genius who made ENIAC possible. Eckert solved the reliability problem by running tubes below their rated voltages and designing fault-tolerant circuits. His attention to detail turned an impossible dream into working hardware.",
                  "stats": [
                    { "label": "Genius", "value": "Electronic circuit design" },
                    { "label": "Obsession", "value": "Reliability through over-engineering" }
                  ]
                }
              ],
              "technicalNotes": [
                {
                  "content": "ENIAC was truly massive: 30 tons, 150 kilowatts of power, 18,000 vacuum tubes, 7,200 crystal diodes, 1,500 relays, 70,000 resistors, 10,000 capacitors, and 6,000 manual switches. It could perform 5,000 additions or 357 multiplications per second‚Äîrevolutionary speed at the time.",
                  "codeSnippet": "// ENIAC specifications\n// Tubes: 17,468\n// Weight: 30 tons\n// Power: 150 kW\n// Floor space: 1,800 sq ft\n// Speed: 5,000 ops/second\n// \n// Comparison:\n// Human computer: 40 hours per trajectory\n// ENIAC: 30 seconds per trajectory\n// Speedup: ~5,000√ó"
                }
              ],
              "nextScene": "scene-2-1-2"
            },
            {
              "id": "scene-2-1-2",
              "type": "narrative",
              "setting": {
                "text": "The tube racks stretch into the distance. Each panel handles a specific function: accumulator, multiplier, divider, function table. Patch cables crisscross like a telephone switchboard gone mad."
              },
              "narrative": [
                "ENIAC isn't programmed with punched cards or stored instructions. It's programmed by physically rewiring the machine. Thousands of switches must be set. Hundreds of cables must be plugged into the correct sockets.",
                "Changing the program takes days. The 'setup' for a new calculation is itself a massive engineering effort.",
                "A team of six women‚Äîmathematicians all‚Äîhandle most of the programming. They've learned ENIAC's architecture more deeply than anyone, turning mathematical problems into switch settings and cable connections."
              ],
              "characters": [
                {
                  "avatar": "üë©‚Äçüíª",
                  "name": "Jean Jennings",
                  "title": "Programmer, ENIAC Project",
                  "bio": "One of the six original ENIAC programmers. Jean and her colleagues learned the machine by studying its logical diagrams‚Äîno programming manual existed. They invented debugging techniques, created subroutines, and established the foundations of software engineering.",
                  "stats": [
                    { "label": "Role", "value": "Lead programmer, problem decomposition" },
                    { "label": "Innovation", "value": "Debugging, modular programming" }
                  ]
                },
                {
                  "avatar": "üë©‚Äçüî¨",
                  "name": "Betty Snyder",
                  "title": "Programmer, ENIAC Project",
                  "bio": "Co-programmer who would later become Betty Holberton. Known for her work on ENIAC's Master Programmer and for proposing the breakpoint debugging technique. She later helped design COBOL and FORTRAN.",
                  "stats": [
                    { "label": "Invention", "value": "Breakpoints for debugging" },
                    { "label": "Later work", "value": "COBOL, FORTRAN standards" }
                  ]
                }
              ],
              "dialogues": [
                {
                  "speaker": "Jennings",
                  "text": "The men built the hardware. We figure out how to make it solve problems. Every switch, every cable‚Äîthey're the instructions. The machine does what we wire it to do."
                },
                {
                  "speaker": "Snyder",
                  "text": "It's like writing a program in physical form. Except when you make a mistake, you have to trace cables through forty panels to find it."
                }
              ],
              "technicalNotes": [
                {
                  "content": "ENIAC's programming was entirely manual: switches and cables formed a 'hardwired' program. Changing the computation meant physically reconfiguring the machine‚Äîa process that could take days. This motivated the development of stored-program computers, where instructions live in memory alongside data.",
                  "codeSnippet": "// ENIAC programming model\n// No stored program!\n// \n// To compute a trajectory:\n// 1. Plug cables to connect accumulators\n// 2. Set switches for constant values\n// 3. Configure function tables for ballistic data\n// 4. Test the configuration\n// 5. Run the computation\n// \n// Setup time: Days\n// Run time: Seconds"
                }
              ],
              "nextScene": "scene-2-1-3"
            },
            {
              "id": "scene-2-1-3",
              "type": "choice",
              "setting": {
                "text": "A new visitor arrives at the Moore School: John von Neumann, the legendary mathematician. He's come to see ENIAC‚Äîbut he's already thinking about what comes next."
              },
              "narrative": [
                "Von Neumann watches the programmers work, asking endless questions. Why is the program hardwired? Why can't instructions be stored in memory like data?",
                "The question will reshape computing forever. But for now, ENIAC must be made to work."
              ],
              "characters": [
                {
                  "avatar": "üß†",
                  "name": "John von Neumann",
                  "title": "Mathematician, Consultant",
                  "bio": "Possibly the greatest mathematical genius of the 20th century. Von Neumann made fundamental contributions to quantum mechanics, game theory, nuclear physics, and computer science. His 'First Draft of a Report on EDVAC' defined the stored-program architecture.",
                  "stats": [
                    { "label": "Legend", "value": "Photographic memory, instant insight" },
                    { "label": "Contribution", "value": "Von Neumann architecture" }
                  ]
                }
              ],
              "choices": [
                {
                  "id": "choice-learn-architecture",
                  "icon": "üîå",
                  "title": "Learn ENIAC's Architecture",
                  "description": "Study the accumulators, multipliers, and function tables. Understand how plug boards create programs.",
                  "nextScene": "scene-2-1-3a"
                },
                {
                  "id": "choice-program-eniac",
                  "icon": "üìê",
                  "title": "Program a Calculation",
                  "description": "Work with the programmers to set up a trajectory computation. Experience hardwired programming firsthand.",
                  "nextScene": "scene-2-1-3b"
                },
                {
                  "id": "choice-von-neumann-insight",
                  "icon": "üí°",
                  "title": "Discuss the Future with von Neumann",
                  "description": "What if programs lived in memory? Explore the stored-program concept that will define all future computers.",
                  "nextScene": "scene-2-1-3c"
                }
              ]
            },
            {
              "id": "scene-2-1-3a",
              "type": "narrative",
              "setting": {
                "text": "Eckert leads you through ENIAC's architecture, panel by panel. The heat is oppressive, but the logic is beautiful."
              },
              "narrative": [
                "ENIAC has twenty 'accumulators'‚Äîeach a 10-digit decimal register built from vacuum tubes. Each digit uses a ring counter: ten flip-flops where exactly one is 'on' at any time. The value is which flip-flop is active.",
                "The accumulators don't just store numbers‚Äîthey can add or subtract. When a pulse arrives, the counter advances. Ten pulses means 'add 10'. It's decimal arithmetic implemented in electronics.",
                "Between the accumulators, Eckert shows you the multiplier unit. 'Multiplication is repeated addition,' he explains. 'The multiplier coordinates hundreds of addition cycles. One multiplication takes 2.8 milliseconds‚Äîthousands of times faster than a human.'"
              ],
              "dialogues": [
                {
                  "speaker": "Eckert",
                  "text": "Every tube here does one thing: it's either on or off. But combine thousands of them the right way, and you get arithmetic. That's the magic‚Äîsimple components creating complex behavior."
                },
                {
                  "speaker": "You",
                  "text": "What happens when a tube fails?"
                },
                {
                  "speaker": "Eckert",
                  "text": "We designed for failure. Every tube runs below its rated voltage. We have spare circuits, redundant paths. Even so, we replace several tubes every day. It's a constant battle."
                }
              ],
              "technicalNotes": [
                {
                  "content": "ENIAC's decimal design was chosen because humans think in decimal. Each digit required 10 flip-flops (one-hot encoding). Binary would have been more efficient‚Äî4 flip-flops per digit‚Äîbut harder for operators to understand. Later computers chose binary for its simplicity.",
                  "codeSnippet": "// ENIAC decimal vs binary storage\n// \n// Decimal (ENIAC):\n// One digit = 10 flip-flops\n// Value 7 = 0000000100 (7th flip-flop on)\n// 10 digits = 100 flip-flops\n// \n// Binary (modern):\n// One digit (0-9) = 4 flip-flops\n// Value 7 = 0111\n// 10 digits = 40 flip-flops\n// \n// Binary wins: 2.5√ó more efficient"
                }
              ],
              "nextScene": "scene-2-1-4"
            },
            {
              "id": "scene-2-1-3b",
              "type": "narrative",
              "setting": {
                "text": "Jean Jennings hands you a wiring diagram. 'This is today's setup,' she says. 'We're computing a trajectory for a 155mm shell at 45 degrees elevation.'"
              },
              "narrative": [
                "Programming ENIAC means connecting the right accumulators with patch cables, setting thousands of switches, and configuring the function tables with ballistic data. There's no 'code' in the modern sense‚Äîjust physical connections.",
                "Jennings walks you through the process. 'First, we break the problem into operations. Then we figure out which accumulator does what. Then we connect them in the right sequence.'",
                "You help plug cables, following her diagram. Each connection must be perfect. One wrong cable and the calculation gives nonsense‚Äîor worse, damages the machine."
              ],
              "dialogues": [
                {
                  "speaker": "Jennings",
                  "text": "See this cable? It carries the current velocity value from accumulator 3 to accumulator 7, where it's combined with air resistance. Every cable is a data path. Every switch is an instruction."
                },
                {
                  "speaker": "You",
                  "text": "How long did it take to set this up?"
                },
                {
                  "speaker": "Jennings",
                  "text": "Three days for this trajectory calculation. And if we find an error, we have to trace every connection to find it. Betty invented a technique‚Äîshe calls it 'debugging.' We're all bugs hunting through these wires."
                }
              ],
              "technicalNotes": [
                {
                  "content": "The ENIAC programmers‚Äîall women mathematicians‚Äîdeveloped debugging techniques that would define software engineering. Betty Holberton invented breakpoints: stopping the machine at specific points to examine values. They also created reusable 'subroutines'‚Äîcommon operations pre-wired and called as needed.",
                  "codeSnippet": "// ENIAC 'programming' steps\n// \n// 1. Mathematical analysis\n//    Break problem into operations\n// \n// 2. Flow diagram\n//    Map operations to accumulators\n// \n// 3. Wiring setup\n//    Plug cables, set switches\n//    (Takes days)\n// \n// 4. Testing\n//    Run with known values\n//    Debug using breakpoints\n// \n// 5. Production runs\n//    (Takes seconds each)"
                }
              ],
              "nextScene": "scene-2-1-4"
            },
            {
              "id": "scene-2-1-3c",
              "type": "dialogue",
              "setting": {
                "text": "Von Neumann sits in a quiet corner of the Moore School, away from ENIAC's roar. His eyes are alive with calculation."
              },
              "dialogues": [
                {
                  "speaker": "Von Neumann",
                  "text": "ENIAC is magnificent‚Äîbut limited. Every new problem requires rewiring. What if the wiring instructions themselves were stored in memory?"
                },
                {
                  "speaker": "You",
                  "text": "Instructions in memory? Like the data?"
                },
                {
                  "speaker": "Von Neumann",
                  "text": "Exactly! The machine reads an instruction, executes it, reads the next. The program becomes just another pattern of bits. Change the program by changing memory, not by moving cables."
                },
                {
                  "speaker": "You",
                  "text": "But how would that work? The machine would need to know what each instruction means."
                },
                {
                  "speaker": "Von Neumann",
                  "text": "A decoder. A small piece of hardware that interprets instruction codes. '0001' means add. '0010' means subtract. The decoder is fixed; the program is flexible. This is the key insight."
                },
                {
                  "speaker": "You",
                  "text": "And the program could change itself? Modify its own instructions?"
                },
                {
                  "speaker": "Von Neumann",
                  "text": "Now you see it! A program that writes programs. A machine that improves itself. The implications are... profound. This is what we're designing for EDVAC."
                }
              ],
              "technicalNotes": [
                {
                  "content": "Von Neumann's 'First Draft of a Report on the EDVAC' (1945) established the stored-program concept. Programs and data share the same memory. Instructions are fetched, decoded, and executed in sequence. Self-modifying code becomes possible. This architecture‚Äînow called 'von Neumann architecture'‚Äîunderlies virtually all computers today.",
                  "codeSnippet": "// Von Neumann's insight\n// \n// ENIAC: Program = Physical wiring\n//        Hardcoded, inflexible\n// \n// EDVAC: Program = Data in memory\n//        Flexible, modifiable\n// \n// Key implication:\n// Programs can modify themselves!\n// \n// memory[100] = ADD instruction\n// memory[100] = memory[100] + 1\n// Now memory[100] = SUB instruction\n// \n// Enables: loops, subroutines, compilers"
                }
              ],
              "nextScene": "scene-2-1-4"
            },
            {
              "id": "scene-2-1-4",
              "type": "challenge",
              "setting": {
                "text": "The ENIAC simulator awaits. Experience the challenge of vacuum tube logic: incredible speed, incredible heat, incredible unreliability."
              },
              "narrative": [
                "Build a simple computation unit using vacuum tube logic. Feel the power‚Äîand the limitations‚Äîof the first electronic computers.",
                "Each tube consumes power, generates heat, and might fail at any moment. This is computing in the heroic age."
              ],
              "challenge": {
                "title": "BUILD A VACUUM TUBE ACCUMULATOR",
                "objectives": [
                  { "id": "obj-1", "text": "Implement a flip-flop (bistable circuit) from tubes", "completed": false },
                  { "id": "obj-2", "text": "Chain flip-flops into a 4-bit register", "completed": false },
                  { "id": "obj-3", "text": "Add increment logic (counting circuit)", "completed": false },
                  { "id": "obj-4", "text": "Add a pulse input for parallel loading", "completed": false },
                  { "id": "obj-5", "text": "Demonstrate: store, increment, clear operations", "completed": false }
                ]
              },
              "technicalNotes": [
                {
                  "content": "ENIAC used decimal arithmetic, with each digit stored in a 10-state ring counter (10 flip-flops, one hot). This was inefficient compared to binary but matched the decimal calculations humans were used to. Later machines would switch to binary for simplicity and density.",
                  "codeSnippet": "// ENIAC digit storage\n// Ring counter: 10 flip-flops per digit\n// Only one flip-flop 'on' at a time\n// Value 0: First flip-flop on\n// Value 9: Tenth flip-flop on\n// \n// Binary alternative:\n// 4 flip-flops store 0-15\n// More efficient, less intuitive\n// \n// ENIAC used decimal because\n// humans think in decimal"
                }
              ],
              "nextScene": "scene-2-1-5"
            },
            {
              "id": "scene-2-1-5",
              "type": "dialogue",
              "setting": {
                "text": "February 14, 1946. ENIAC is unveiled to the public. Reporters crowd the Moore School, watching in amazement as the machine calculates a trajectory faster than the shell itself could fly."
              },
              "dialogues": [
                {
                  "speaker": "Mauchly",
                  "text": "ENIAC computes in thirty seconds what takes a human forty hours. This is the dawn of a new age‚Äîthe electronic age."
                },
                {
                  "speaker": "Von Neumann",
                  "text": "It's magnificent. But limited. Every new problem requires rewiring the machine. We need to store the program in memory‚Äîmake the machine truly flexible."
                },
                {
                  "speaker": "Eckert",
                  "text": "That's EDVAC. We're already designing it. Stored program. Mercury delay-line memory. Everything in binary."
                },
                {
                  "speaker": "Von Neumann",
                  "text": "The program becomes data. The machine can modify its own instructions. The implications... the implications are staggering."
                }
              ],
              "narrative": [
                "ENIAC would operate for ten years, solving problems from hydrogen bomb calculations to weather prediction. But its architecture‚Äîhardwired programs‚Äîwas already obsolete at its unveiling.",
                "The future belonged to stored-program computers: machines that could switch from task to task by loading new instructions from memory. Machines that could modify their own behavior. Machines that were truly universal.",
                "Von Neumann's architecture would define computing for the next eighty years. And it started here, watching ENIAC's tubes glow in the Philadelphia night."
              ]
            }
          ]
        },
        {
          "id": "chapter-2-2",
          "number": 2,
          "title": "The First Draft",
          "subtitle": "The Birth of the Stored Program",
          "year": "1945",
          "scenes": [
            {
              "id": "scene-2-2-1",
              "type": "narrative",
              "setting": {
                "text": "A train from Los Alamos to Philadelphia. John von Neumann sits with a notepad, sketching diagrams. The Manhattan Project is winding down, and his mind turns to a different kind of explosion: computational power."
              },
              "narrative": [
                "Von Neumann has been thinking about ENIAC's limitations. The hardwired programming is elegant for single problems but hopeless for flexibility. What if the program itself was stored in memory?",
                "On this train ride, he begins writing what will become the most influential document in computer history: 'First Draft of a Report on the EDVAC.'",
                "EDVAC‚Äîthe Electronic Discrete Variable Automatic Computer‚Äîwill be ENIAC's successor. And it will change everything."
              ],
              "technicalNotes": [
                {
                  "content": "The 'First Draft' described a computer with five logical components: input, output, memory, arithmetic unit, and control unit. Programs and data share the same memory. Instructions are fetched, decoded, and executed in sequence. This 'von Neumann architecture' remains the foundation of virtually all computers today.",
                  "codeSnippet": "// Von Neumann Architecture\n// \n// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n// ‚îÇ Memory  ‚îÇ ‚Üê Programs AND data\n// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n//      ‚îÇ\n// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n// ‚îÇ Control ‚îÇ ‚Üê‚Üí ‚îÇ  ALU    ‚îÇ\n// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n//      ‚îÇ\n// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n// ‚îÇ  Input  ‚îÇ    ‚îÇ Output  ‚îÇ\n// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
                }
              ],
              "nextScene": "scene-2-2-2"
            },
            {
              "id": "scene-2-2-2",
              "type": "narrative",
              "setting": {
                "text": "The Moore School seminar room. Engineers, mathematicians, and physicists crowd in to hear von Neumann explain the stored-program concept."
              },
              "narrative": [
                "Von Neumann stands at the chalkboard, drawing boxes and arrows. 'The program,' he says, 'is just another kind of data. Store it in memory. Fetch instructions like you fetch numbers. The machine becomes universal.'",
                "The audience is stunned. Programs that modify themselves. Loops, branches, subroutines‚Äîall flow naturally from this insight.",
                "But there's a problem: where do you store all this data and code? ENIAC's accumulators hold only twenty ten-digit numbers. EDVAC will need thousands of words of memory."
              ],
              "dialogues": [
                {
                  "speaker": "Von Neumann",
                  "text": "The memory is the key. Fast, cheap, reliable memory. With enough memory, a simple processor can do anything. Without it, the fastest processor is useless."
                },
                {
                  "speaker": "Eckert",
                  "text": "Mercury delay lines. Sound pulses cycling through tubes of mercury. A thousand words of memory, refreshed continuously."
                },
                {
                  "speaker": "Von Neumann",
                  "text": "Elegant. The data exists as waves in transit, renewed each millisecond. A memory that remembers by constantly repeating."
                }
              ],
              "technicalNotes": [
                {
                  "content": "Mercury delay-line memory stored data as acoustic pulses traveling through tubes of mercury. A pulse took about 1ms to traverse the tube, was detected, amplified, and re-injected‚Äîcreating a circulating memory. Slow, but cheap and reliable compared to alternatives.",
                  "codeSnippet": "// Mercury delay line memory\n// \n// Transducer ‚Üí [Mercury tube] ‚Üí Transducer\n//      ‚Üë                            ‚Üì\n//      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Amplifier ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n// \n// Data circulates continuously\n// Access time: Variable (wait for bit to arrive)\n// Typical: 1024 bits per line\n// EDVAC: 128 lines = 1024 words"
                }
              ],
              "nextScene": "scene-2-2-3"
            },
            {
              "id": "scene-2-2-3",
              "type": "choice",
              "setting": {
                "text": "The design takes shape. EDVAC will have memory, arithmetic, control, input, output. But the details‚Äîthe instruction set, the addressing modes, the control flow‚Äîare still debated."
              },
              "narrative": [
                "You've been asked to help design EDVAC's instruction set. What operations should the machine support? How many bits per instruction? How should memory be addressed?",
                "Every choice has consequences. More instructions mean more complex control logic. Longer words mean more memory but slower access. The art of computer architecture is beginning."
              ],
              "choices": [
                {
                  "id": "choice-instruction-design",
                  "icon": "üìã",
                  "title": "Design the Instruction Set",
                  "description": "Define what operations EDVAC will support. Balance power against complexity.",
                  "nextScene": "scene-2-2-3a"
                },
                {
                  "id": "choice-memory-architecture",
                  "icon": "üß†",
                  "title": "Explore Memory Architecture",
                  "description": "Understand mercury delay lines, Williams tubes, and the memory technologies of the era.",
                  "nextScene": "scene-2-2-3b"
                },
                {
                  "id": "choice-fetch-execute",
                  "icon": "üîÑ",
                  "title": "Implement the Fetch-Execute Cycle",
                  "description": "Build the core loop of all stored-program computers: fetch, decode, execute, repeat.",
                  "nextScene": "scene-2-2-3c"
                }
              ]
            },
            {
              "id": "scene-2-2-3a",
              "type": "narrative",
              "setting": {
                "text": "A chalkboard fills with opcodes and bit patterns. Von Neumann leads the discussion: what instructions does a universal computer need?"
              },
              "narrative": [
                "The debate is fundamental: how many instructions should a computer have? Too few, and programming becomes tedious‚Äîevery operation requires many steps. Too many, and the control logic becomes impossibly complex.",
                "Von Neumann argues for minimalism. 'A small set of operations, used cleverly, can compute anything. The complexity should be in the program, not the hardware.'",
                "The proposed EDVAC instruction set takes shape: arithmetic (add, subtract, multiply, divide), data movement (load, store), and control flow (jump, conditional branch). About a dozen instructions total."
              ],
              "dialogues": [
                {
                  "speaker": "Von Neumann",
                  "text": "Consider: with just ADD, NEGATE, and conditional JUMP, you can compute anything computable. Subtraction is addition of the negation. Multiplication is repeated addition. We need only the primitives."
                },
                {
                  "speaker": "Eckert",
                  "text": "But efficiency matters! A hardware multiplier is a thousand times faster than repeated addition. Users will need multiplication constantly."
                },
                {
                  "speaker": "Von Neumann",
                  "text": "Agreed. We include what's commonly needed: arithmetic, memory access, branching. But no more. Every instruction we add is more tubes, more heat, more failure points."
                }
              ],
              "technicalNotes": [
                {
                  "content": "EDVAC's instruction set included about 12 operations. Modern RISC processors have 50-100. Modern x86 has thousands (most rarely used). The debate between minimal and complex instruction sets continues‚ÄîRISC vs CISC. Von Neumann favored simplicity; the market often chose features.",
                  "codeSnippet": "// EDVAC-style minimal instruction set\n// \n// Arithmetic:\n// ADD   - Add memory to accumulator\n// SUB   - Subtract memory from accumulator\n// MUL   - Multiply\n// DIV   - Divide\n// \n// Memory:\n// LOAD  - Memory to accumulator\n// STORE - Accumulator to memory\n// \n// Control:\n// JUMP  - Unconditional branch\n// JZ    - Jump if accumulator is zero\n// HALT  - Stop execution\n// \n// ~12 instructions total"
                }
              ],
              "nextScene": "scene-2-2-4"
            },
            {
              "id": "scene-2-2-3b",
              "type": "narrative",
              "setting": {
                "text": "The memory laboratory. Tubes of mercury line the walls. In the corner, a cathode ray tube flickers with strange patterns."
              },
              "narrative": [
                "Memory is the bottleneck of early computing. ENIAC has only 20 words of fast storage (in its accumulators). EDVAC needs thousands. But how do you store thousands of bits electronically?",
                "Eckert shows you the mercury delay line. Sound pulses travel through a tube of mercury at about 1,500 meters per second. A one-meter tube delays a pulse by 0.7 milliseconds. Detect the pulse at the end, amplify it, send it back to the start‚Äîthe data circulates forever.",
                "But delay lines are slow: you must wait for your data to 'come around' in the loop. Random access is impossible. Manchester's Williams tube offers an alternative: store bits as dots on a CRT screen, read them instantly."
              ],
              "dialogues": [
                {
                  "speaker": "Eckert",
                  "text": "Each delay line holds about 1,000 bits. The bit you want might be anywhere in the loop. Average access time: half a millisecond. Not fast, but the memory is cheap and reliable."
                },
                {
                  "speaker": "You",
                  "text": "What about the Williams tube? Instant access to any bit?"
                },
                {
                  "speaker": "Eckert",
                  "text": "Promising, but unproven. The charge leaks away‚Äîyou must constantly refresh it. And the CRT itself is fragile. For EDVAC, we're betting on mercury. It works."
                }
              ],
              "technicalNotes": [
                {
                  "content": "Memory technologies of the late 1940s: Mercury delay lines (serial, cheap, reliable). Williams tubes (random-access, fast, fragile). Magnetic drum (mechanical, huge capacity, very slow). Core memory (coming soon‚Äîwould dominate for 20 years). Each had tradeoffs that shaped computer design.",
                  "codeSnippet": "// Memory technologies circa 1950\n// \n// Mercury delay line:\n//   Capacity: ~1 Kbit per tube\n//   Access: Serial (avg 0.5ms)\n//   Cost: Low\n//   Reliability: High\n// \n// Williams tube (CRT):\n//   Capacity: ~1 Kbit per tube\n//   Access: Random (<1¬µs)\n//   Cost: Medium\n//   Reliability: Low (needs refresh)\n// \n// Magnetic drum:\n//   Capacity: 10+ Kbits\n//   Access: Serial (10-20ms)\n//   Cost: High\n//   Reliability: High"
                }
              ],
              "nextScene": "scene-2-2-4"
            },
            {
              "id": "scene-2-2-3c",
              "type": "narrative",
              "setting": {
                "text": "A simplified control unit diagram covers the blackboard. This is the heartbeat of the stored-program computer."
              },
              "narrative": [
                "Von Neumann traces the cycle: 'First, fetch. The program counter holds an address. Read the instruction at that address. Second, decode. What operation? What operands? Third, execute. Perform the operation. Fourth, update. Advance the program counter. Fifth, repeat.'",
                "This cycle‚Äîfetch, decode, execute‚Äîis the fundamental rhythm of computation. Every computer from EDVAC to the latest smartphone follows it, billions of times per second.",
                "The beauty is in the simplicity. The same memory holds both data and instructions. The same buses carry both. The control unit doesn't know the difference‚Äîit just follows the cycle."
              ],
              "dialogues": [
                {
                  "speaker": "Von Neumann",
                  "text": "The program counter is just a register that holds an address. Fetch loads the instruction. Decode parses it. Execute performs it. Then we increment the counter and repeat. Simplicity itself."
                },
                {
                  "speaker": "You",
                  "text": "What about jumps? Loops? How do you break out of the sequence?"
                },
                {
                  "speaker": "Von Neumann",
                  "text": "A jump instruction simply writes a new value to the program counter. The next fetch reads from that new address. Control flow becomes data flow. It's elegant, don't you think?"
                }
              ],
              "technicalNotes": [
                {
                  "content": "The fetch-execute cycle was von Neumann's key insight. Instructions are data. The program counter sequences through memory. Jumps modify the counter. Modern CPUs pipeline this cycle, executing multiple instructions simultaneously, but the fundamental concept remains unchanged.",
                  "codeSnippet": "// The fetch-execute cycle\n// \n// while (running) {\n//   // FETCH\n//   instruction = memory[PC]\n//   PC = PC + 1\n//   \n//   // DECODE\n//   opcode = instruction[31:24]\n//   operand = instruction[23:0]\n//   \n//   // EXECUTE\n//   switch (opcode) {\n//     ADD:  ACC = ACC + memory[operand]\n//     LOAD: ACC = memory[operand]\n//     JUMP: PC = operand\n//     HALT: running = false\n//   }\n// }"
                }
              ],
              "nextScene": "scene-2-2-4"
            },
            {
              "id": "scene-2-2-4",
              "type": "challenge",
              "setting": {
                "text": "Your simulation bench transforms into an EDVAC-style stored-program computer. Build the control unit‚Äîthe heart of the von Neumann architecture."
              },
              "narrative": [
                "The control unit orchestrates everything: fetching instructions from memory, decoding them, signaling the ALU, updating the program counter. It's the conductor of the electronic orchestra.",
                "Build the fetch-execute cycle. This is the fundamental rhythm of all computation."
              ],
              "challenge": {
                "title": "BUILD THE FETCH-EXECUTE CYCLE",
                "objectives": [
                  { "id": "obj-1", "text": "Implement the program counter (PC) register", "completed": false },
                  { "id": "obj-2", "text": "Fetch instruction from memory at address PC", "completed": false },
                  { "id": "obj-3", "text": "Decode instruction into operation and operands", "completed": false },
                  { "id": "obj-4", "text": "Execute the operation (load, store, add, jump)", "completed": false },
                  { "id": "obj-5", "text": "Update PC and repeat", "completed": false },
                  { "id": "obj-6", "text": "Run a simple program: add two numbers in memory", "completed": false }
                ]
              },
              "technicalNotes": [
                {
                  "content": "The fetch-execute cycle is the heartbeat of computing: 1) Fetch the instruction at the address in PC. 2) Increment PC. 3) Decode the instruction. 4) Execute it (possibly modifying PC for jumps). 5) Repeat. Every computer from EDVAC to the latest smartphone follows this basic pattern.",
                  "codeSnippet": "// Fetch-Execute Cycle\n// \nwhile (running) {\n  instruction = memory[PC];\n  PC = PC + 1;\n  \n  opcode = decode(instruction);\n  operands = extract_operands(instruction);\n  \n  switch (opcode) {\n    case LOAD: ACC = memory[operands];\n    case STORE: memory[operands] = ACC;\n    case ADD: ACC = ACC + memory[operands];\n    case JUMP: PC = operands;\n    // ...\n  }\n}"
                }
              ],
              "nextScene": "scene-2-2-5"
            },
            {
              "id": "scene-2-2-5",
              "type": "dialogue",
              "setting": {
                "text": "1949. EDVAC finally runs its first programs‚Äîdelayed by disputes, departures, and the challenges of a radically new architecture. But the idea spreads faster than the machine itself."
              },
              "dialogues": [
                {
                  "speaker": "Von Neumann",
                  "text": "EDVAC is one machine. But the architecture‚Äîthe stored-program concept‚Äîthat's universal. Already Cambridge is building EDSAC. Manchester has the Baby. The idea is spreading."
                },
                {
                  "speaker": "Eckert",
                  "text": "We're leaving academia. Mauchly and I are starting a company. We're going to build computers for business, not just science."
                },
                {
                  "speaker": "You",
                  "text": "Computers for business? Who would buy them?"
                },
                {
                  "speaker": "Eckert",
                  "text": "Anyone who processes data. Insurance companies. Banks. The Census Bureau. We're calling it UNIVAC‚ÄîUniversal Automatic Computer."
                }
              ],
              "narrative": [
                "The stored-program concept was the key that unlocked general-purpose computing. No longer hardwired to a single task, computers could now be reprogrammed simply by loading new instructions into memory.",
                "But vacuum tube computers were still massive, expensive, and power-hungry. They were tools for governments and giant corporations, not ordinary people.",
                "That would change. But first, the vacuum tube era would reach its peak‚Äîand its limit."
              ]
            }
          ]
        },
        {
          "id": "chapter-2-2b",
          "number": 2.5,
          "title": "The First True Computers",
          "subtitle": "Manchester Baby and EDSAC",
          "year": "1948-1949",
          "scenes": [
            {
              "id": "scene-2-2b-1",
              "type": "narrative",
              "setting": {
                "text": "University of Manchester, England. June 21, 1948. In a cramped laboratory, a machine the size of a room flickers to life. It has no keyboard, no printer‚Äîjust lights and switches. But it's about to make history."
              },
              "narrative": [
                "The Manchester Baby‚Äîofficially the Small-Scale Experimental Machine (SSEM)‚Äîis about to run the world's first stored program. Not hardwired like ENIAC. Not theoretical like EDVAC. An actual program, loaded into electronic memory, executed instruction by instruction.",
                "The program is simple: find the highest proper factor of a number. It will take 52 minutes to run, testing 3.5 million possible factors. A human could do it faster. But that's not the point.",
                "The point is that the program lives in memory. The machine fetches each instruction, executes it, moves to the next. The stored-program computer‚Äîvon Neumann's dream‚Äîis finally real."
              ],
              "characters": [
                {
                  "avatar": "üë®‚Äçüî¨",
                  "name": "Frederic Williams",
                  "title": "Professor of Engineering, Manchester",
                  "bio": "Inventor of the Williams tube‚Äîa CRT-based memory that could store bits as dots on a screen. This breakthrough solved the memory problem that plagued all early computers.",
                  "stats": [
                    { "label": "Innovation", "value": "Williams tube memory" },
                    { "label": "Significance", "value": "First practical random-access memory" }
                  ]
                },
                {
                  "avatar": "üîß",
                  "name": "Tom Kilburn",
                  "title": "Lecturer, Manchester",
                  "bio": "Designed and built the Manchester Baby with Williams. Kilburn wrote the first program ever to run on a stored-program computer‚Äîa 17-instruction routine to find factors.",
                  "stats": [
                    { "label": "First Program", "value": "Factor-finding, June 1948" },
                    { "label": "Instructions", "value": "17 lines of code" }
                  ]
                }
              ],
              "technicalNotes": [
                {
                  "content": "The Williams tube used a CRT to store bits as electrostatic charges. A focused electron beam could write dots (1) or dashes (0) on the screen's phosphor coating. Reading detected the capacitive change. This was the first random-access electronic memory‚Äîany bit could be accessed instantly, unlike serial delay lines.",
                  "codeSnippet": "// Manchester Baby specifications\n// Memory: 32 words √ó 32 bits (Williams tube)\n// Instructions: 7 (JMP, JRP, LDN, STO, SUB, CMP, STP)\n// Clock: 1.1 MHz\n// \n// First stored program (June 21, 1948):\n// Find largest proper factor of 2^18\n// Runtime: 52 minutes\n// Instructions executed: 3.5 million\n// \n// FIRST STORED-PROGRAM COMPUTER TO RUN"
                }
              ],
              "nextScene": "scene-2-2b-2"
            },
            {
              "id": "scene-2-2b-2",
              "type": "narrative",
              "setting": {
                "text": "Cambridge University Computing Laboratory. May 6, 1949. Maurice Wilkes and his team have built EDSAC‚Äîthe Electronic Delay Storage Automatic Calculator. Unlike the Baby, this machine is designed to be useful."
              },
              "narrative": [
                "Wilkes attended the Moore School lectures in 1946, returned to England inspired, and immediately began building. While Americans debated EDVAC's design, Wilkes finished EDSAC‚Äîthe first practical stored-program computer.",
                "EDSAC isn't a prototype. It has real memory (512 words), real I/O (paper tape), and real programs. Scientists from across Cambridge are already lining up to use it for calculations.",
                "One of Wilkes's collaborators is particularly important: Kathleen Booth, who has invented something that will make programming possible for mere mortals‚Äîassembly language."
              ],
              "characters": [
                {
                  "avatar": "üìê",
                  "name": "Maurice Wilkes",
                  "title": "Director, Cambridge Computing Laboratory",
                  "bio": "Built EDSAC in under three years by focusing on simplicity and practicality. Wilkes later invented microprogramming, a technique still used in modern CPUs.",
                  "stats": [
                    { "label": "Achievement", "value": "First practical stored-program computer" },
                    { "label": "Later Work", "value": "Microprogramming, cache memory" }
                  ]
                },
                {
                  "avatar": "üë©‚Äçüíª",
                  "name": "Kathleen Booth",
                  "title": "Researcher, Birkbeck College",
                  "bio": "Co-invented assembly language and wrote the first assembler. Her work on the ARC computer and its programming language made programming accessible to non-specialists. Also contributed to the first neural network simulation.",
                  "stats": [
                    { "label": "Innovation", "value": "Assembly language, first assembler" },
                    { "label": "Legacy", "value": "Made programming human-readable" }
                  ]
                }
              ],
              "dialogues": [
                {
                  "speaker": "Wilkes",
                  "text": "The Americans have theories and blueprints. We have a working machine. EDSAC ran its first calculation today‚Äîcomputing a table of squares."
                },
                {
                  "speaker": "Booth",
                  "text": "But programming in raw machine code is misery. Every number, every address must be worked out by hand. We need a language that humans can read‚Äîand a program to translate it."
                }
              ],
              "technicalNotes": [
                {
                  "content": "EDSAC used mercury delay-line memory, holding 512 words of 17 bits each. It ran its first program on May 6, 1949‚Äîalmost a year after Manchester Baby but far more practical. EDSAC calculated the first scientific computations performed by a stored-program computer.",
                  "codeSnippet": "// EDSAC vs Manchester Baby\n// \n// Manchester Baby (June 1948):\n//   First stored-program execution\n//   32 words memory, 7 instructions\n//   Experimental prototype\n// \n// EDSAC (May 1949):\n//   First PRACTICAL stored-program computer\n//   512 words memory, 18 instructions\n//   Used for real scientific work\n//   Paper tape I/O, subroutine library"
                }
              ],
              "nextScene": "scene-2-2b-3"
            },
            {
              "id": "scene-2-2b-3",
              "type": "narrative",
              "setting": {
                "text": "Kathleen Booth's desk at Birkbeck College, London. She's working on the ARC computer, but her real breakthrough is on paper: a notation that lets programmers write code in words, not numbers."
              },
              "narrative": [
                "Machine code is binary: ones and zeros, or numbers representing them. To add two numbers, you might write '15 0 100 101'‚Äîopcode, address, operand, operand. Cryptic. Error-prone. Inhuman.",
                "Booth's insight: let programmers write 'ADD R0, X, Y' instead. A program‚Äîan assembler‚Äîcan translate the human-readable form into machine code. The machine does the tedious translation; humans write in a language they can understand.",
                "It seems obvious now. In 1947, it was revolutionary. Assembly language would become the first level of abstraction between humans and machines‚Äîthe ancestor of every programming language."
              ],
              "dialogues": [
                {
                  "speaker": "Booth",
                  "text": "I call it 'assembly language' because it assembles the final machine code from symbolic pieces. ADD means addition. R0 means register zero. The assembler handles the translation."
                },
                {
                  "speaker": "You",
                  "text": "So the machine learns to read human notation?"
                },
                {
                  "speaker": "Booth",
                  "text": "The machine doesn't learn‚Äîthe assembler is just a program that does the translation mechanically. But yes, it means we can write programs that make sense to human eyes. That changes everything."
                }
              ],
              "technicalNotes": [
                {
                  "content": "Kathleen Booth's 1947 work on assembly language for the ARC computer was groundbreaking. Before assembly, programmers wrote raw machine code‚Äînumeric opcodes and addresses. Assembly introduced mnemonics (ADD, SUB, JMP) and symbolic labels, making code readable. Modern assembly languages descend directly from her invention.",
                  "codeSnippet": "// Machine code vs Assembly language\n// \n// Machine code (raw numbers):\n// 01 02 64 65    ; Cryptic, error-prone\n// \n// Assembly language (Booth's invention):\n// ADD R0, X, Y   ; Human-readable!\n// \n// The assembler translates:\n// Symbol ‚Üí Address\n// Mnemonic ‚Üí Opcode\n// Label ‚Üí Numeric value\n// \n// First level of programming abstraction"
                }
              ],
              "nextScene": "scene-2-2b-4"
            },
            {
              "id": "scene-2-2b-4",
              "type": "dialogue",
              "setting": {
                "text": "Back at Cambridge, EDSAC is running constantly. A subroutine library grows‚Äîreusable code that any programmer can call. The foundations of software engineering are being laid."
              },
              "dialogues": [
                {
                  "speaker": "Wilkes",
                  "text": "We're building a library of subroutines. Square roots, trigonometry, input/output. Write once, use forever. Programming becomes combining existing pieces."
                },
                {
                  "speaker": "You",
                  "text": "So the Americans didn't actually build the first stored-program computer?"
                },
                {
                  "speaker": "Wilkes",
                  "text": "They invented the concept. Von Neumann's report was brilliant. But while they debated, we built. EDVAC didn't run until 1951‚Äîtwo years after EDSAC. Manchester beat everyone with the Baby in 1948."
                },
                {
                  "speaker": "Booth",
                  "text": "The lesson? Ideas are wonderful, but working machines change the world. And machines need programs‚Äîwhich means they need languages humans can write."
                }
              ],
              "narrative": [
                "The race to build the first stored-program computer ended in Britain. Manchester's Baby ran first, in June 1948. Cambridge's EDSAC followed in May 1949, proving the concept could be practical. American EDVAC, the machine that inspired them all, didn't run until 1951.",
                "Kathleen Booth's assembly language would transform programming from an esoteric art into an accessible skill. Grace Hopper‚Äîworking with UNIVAC‚Äîwould soon take the next step: compilers that translated high-level languages into machine code.",
                "The vacuum tube giants were reaching their peak. But the real revolution was happening at Bell Labs, where three physicists were about to change everything."
              ],
              "nextScene": "chapter-2-3"
            }
          ]
        },
        {
          "id": "chapter-2-3",
          "number": 3,
          "title": "The Electronic Brain",
          "subtitle": "UNIVAC and the Dawn of Commercial Computing",
          "year": "1951",
          "scenes": [
            {
              "id": "scene-2-3-1",
              "type": "narrative",
              "setting": {
                "text": "Eckert-Mauchly Computer Corporation, Philadelphia. 1951. The first UNIVAC I gleams under the lights, ready for delivery to the Census Bureau‚Äîthe same agency that launched the mechanical tabulating era sixty years ago."
              },
              "narrative": [
                "UNIVAC is different from its predecessors. It's not a one-off research project‚Äîit's a product. Designed to be manufactured, sold, and operated by customers who aren't computer scientists.",
                "The machine uses magnetic tape for input and output, not punch cards. It has metal memory‚Äîmercury delay lines holding 1,000 twelve-digit words. It can process 1,905 instructions per second.",
                "And it costs half a million dollars. Who could possibly afford such a machine?"
              ],
              "characters": [
                {
                  "avatar": "üíº",
                  "name": "James Rand",
                  "title": "CEO, Remington Rand",
                  "bio": "The businessman who saved UNIVAC. When Eckert and Mauchly's company ran out of money, Rand bought it, providing the resources to complete UNIVAC. He saw computers as the future of data processing.",
                  "stats": [
                    { "label": "Vision", "value": "Computers as business machines" },
                    { "label": "Investment", "value": "Millions in unproven technology" }
                  ]
                }
              ],
              "dialogues": [
                {
                  "speaker": "Eckert",
                  "text": "The Census Bureau is just the first customer. General Electric wants one for payroll. The Army wants one for logistics. Every large organization that processes data will eventually need a computer."
                },
                {
                  "speaker": "Rand",
                  "text": "Half a million dollars is nothing compared to the cost of human clerks. One UNIVAC replaces dozens of tabulating machines and hundreds of workers."
                }
              ],
              "technicalNotes": [
                {
                  "content": "UNIVAC I was the first commercially successful computer. 46 units were sold, each running reliably for years. It used 5,200 vacuum tubes, consumed 125 kW, and weighed 13 tons. But it was maintainable, documented, and‚Äîcrucially‚Äîworked consistently enough for business use.",
                  "codeSnippet": "// UNIVAC I specifications\n// Vacuum tubes: 5,200\n// Memory: 1,000 words √ó 12 characters\n// Speed: 1,905 operations/second\n// Price: ~$1.5M (with peripherals)\n// Units sold: 46\n// \n// Key innovation:\n// First computer designed for\n// production and commercial sale"
                }
              ],
              "nextScene": "scene-2-3-2"
            },
            {
              "id": "scene-2-3-2",
              "type": "narrative",
              "setting": {
                "text": "November 4, 1952. Election night. CBS News has borrowed a UNIVAC to predict the presidential race between Eisenhower and Stevenson."
              },
              "narrative": [
                "The polls say it's too close to call. The pundits predict a long night. But UNIVAC, fed early returns from a few states, makes a bold prediction: Eisenhower will win in a landslide.",
                "The CBS staff don't believe it. The numbers are too decisive, too different from the polls. They adjust UNIVAC's parameters to show a closer race.",
                "By midnight, Eisenhower has won 442 electoral votes to Stevenson's 89. UNIVAC's original prediction was nearly perfect. The staff had been wrong to doubt the machine."
              ],
              "dialogues": [
                {
                  "speaker": "Walter Cronkite",
                  "text": "The electronic brain has spoken. And it was right all along. We humans were the ones who didn't believe it."
                }
              ],
              "technicalNotes": [
                {
                  "content": "UNIVAC's 1952 election prediction was a public relations triumph. Based on returns from just 5% of precincts, it predicted Eisenhower would win with 438 electoral votes (actual: 442). The prediction demonstrated that computers could find patterns humans missed‚Äîa foreshadowing of data science.",
                  "codeSnippet": "// UNIVAC's election algorithm\n// \n// Input: Early returns from selected precincts\n// Historical data: Previous election patterns\n// Method: Statistical regression\n// \n// At 5% returns counted:\n// UNIVAC prediction: Eisenhower 438 EVs\n// Human experts: \"Too close to call\"\n// Actual result: Eisenhower 442 EVs"
                }
              ],
              "nextScene": "scene-2-3-3"
            },
            {
              "id": "scene-2-3-3",
              "type": "choice",
              "setting": {
                "text": "The 'Electronic Brain' has captured the public imagination. Computers are no longer just military secrets‚Äîthey're front-page news."
              },
              "narrative": [
                "UNIVAC's election prediction demonstrated something profound: computers can process information in ways humans cannot. Not just faster, but different‚Äîfinding patterns invisible to the human mind.",
                "But the vacuum tube era is reaching its limits. UNIVAC is reliable, but it still fills a room, consumes a small factory's worth of power, and requires constant maintenance.",
                "Something smaller, cooler, more reliable is needed. Something solid."
              ],
              "choices": [
                {
                  "id": "choice-operate-univac",
                  "icon": "üñ•Ô∏è",
                  "title": "Operate UNIVAC",
                  "description": "Experience the first commercial computer. Load magnetic tapes, run programs, interpret results.",
                  "nextScene": "scene-2-3-3a"
                },
                {
                  "id": "choice-program-univac",
                  "icon": "üìù",
                  "title": "Program in UNIVAC Assembly",
                  "description": "Write code for the UNIVAC I. Learn its instruction set and programming conventions.",
                  "nextScene": "scene-2-3-3b"
                },
                {
                  "id": "choice-understand-limits",
                  "icon": "‚ö†Ô∏è",
                  "title": "Understand the Limits",
                  "description": "Why can't vacuum tube computers scale further? Explore the heat, power, and reliability barriers that demand a new technology.",
                  "nextScene": "scene-2-3-3c"
                }
              ]
            },
            {
              "id": "scene-2-3-3a",
              "type": "narrative",
              "setting": {
                "text": "The UNIVAC operator console. Magnetic tape drives spin. The supervisory typewriter clacks with status messages."
              },
              "narrative": [
                "Operating UNIVAC is a choreographed dance. Mount the program tape on drive A. Mount the data tape on drive B. Set the console switches. Type the start command. Watch the lights.",
                "The operator shows you the sequence. 'First, we load the program. UNIVAC reads the tape at 100 characters per second‚Äîfast for its time. Then we load the data. Then we run.'",
                "The machine hums to life. Tape reels spin, stop, spin again. The mercury delay lines pulse with data. After fifteen minutes, the printer chatters out results: a payroll calculation for General Electric."
              ],
              "dialogues": [
                {
                  "speaker": "Operator",
                  "text": "Every morning we run diagnostics. Check the tubes, verify the memory, test the arithmetic unit. If anything's wrong, we find it before the customers' jobs run."
                },
                {
                  "speaker": "You",
                  "text": "How often do tubes fail?"
                },
                {
                  "speaker": "Operator",
                  "text": "One or two a week, usually. We keep a full set of spares. The secret is running them cool‚Äîbelow their rated voltage. UNIVAC is more reliable than ENIAC ever was, but it still needs constant care."
                }
              ],
              "technicalNotes": [
                {
                  "content": "UNIVAC operators were highly trained specialists. They managed tape mounts, monitored console lights, interpreted error codes, and performed routine maintenance. A good operator could double a machine's effective throughput by minimizing idle time between jobs.",
                  "codeSnippet": "// UNIVAC I operation sequence\n// \n// 1. Mount program tape (Drive A)\n// 2. Mount data tape (Drive B)\n// 3. Mount output tape (Drive C)\n// 4. Set console switches for job type\n// 5. Type RUN on supervisory typewriter\n// 6. Monitor status lights\n// 7. Replace tape if TAPE ERROR light\n// 8. Retrieve output tape when COMPLETE\n// 9. Print results on UNIPRINTER\n// \n// Typical job: 15-30 minutes"
                }
              ],
              "nextScene": "scene-2-3-4"
            },
            {
              "id": "scene-2-3-3b",
              "type": "narrative",
              "setting": {
                "text": "The programming office. Coding sheets cover every desk. A woman in a Navy uniform reviews a stack of instructions."
              },
              "narrative": [
                "Grace Hopper looks up from her work. 'You want to learn UNIVAC programming? Good. We need more programmers. The machine is faster than all of us combined.'",
                "UNIVAC uses a fixed-point decimal system. Each word holds 12 characters. Instructions specify an operation code and one or two memory addresses. It's cryptic, but there's a logic to it.",
                "Hopper shows you a sample program: adding two numbers. 'Load the first number into the accumulator. Add the second. Store the result. Three instructions for something you'd do in your head instantly. But the machine does it in milliseconds‚Äîand never makes arithmetic errors.'"
              ],
              "dialogues": [
                {
                  "speaker": "Hopper",
                  "text": "Programming is like writing very precise recipes. Every step must be exact. The machine does exactly what you tell it‚Äîno more, no less. If your program is wrong, the machine cheerfully gives you wrong answers."
                },
                {
                  "speaker": "You",
                  "text": "Is there an easier way? Writing in numbers is hard."
                },
                {
                  "speaker": "Hopper",
                  "text": "I'm working on that. What if we could write in something closer to English, and have a program translate it to machine code? I call it a 'compiler.' Most people think I'm crazy."
                }
              ],
              "technicalNotes": [
                {
                  "content": "Grace Hopper pioneered the compiler concept at Remington Rand. Her A-0 system (1952) was the first compiler‚Äîa program that translated symbolic code into machine instructions. This led to FLOW-MATIC and eventually COBOL. Hopper proved that programs could write programs.",
                  "codeSnippet": "// UNIVAC programming evolution\n// \n// 1951: Machine code only\n// A0 00 0100 0200  ; Add [100] to [200]\n// \n// 1952: A-0 compiler (Hopper)\n// ADD X Y          ; Symbolic notation\n// \n// 1957: FLOW-MATIC (Hopper)\n// ADD PRICE TO TOTAL  ; English-like!\n// \n// 1959: COBOL\n// ADD ITEM-PRICE TO ORDER-TOTAL\n// GIVING NEW-TOTAL."
                }
              ],
              "nextScene": "scene-2-3-4"
            },
            {
              "id": "scene-2-3-3c",
              "type": "narrative",
              "setting": {
                "text": "The UNIVAC maintenance bay. Rows of replacement tubes, testing equipment, and cooling system diagrams."
              },
              "narrative": [
                "The chief engineer explains the math. 'UNIVAC has 5,200 tubes. Each tube has a mean time between failures of maybe 10,000 hours. That means, on average, a tube fails every two hours. We've improved that with better tubes and lower voltages, but the fundamental problem remains.'",
                "Heat is the killer. Each tube dissipates several watts. Five thousand tubes means 125 kilowatts of heat‚Äîenough to warm a small building. The cooling system is as complex as the computer itself.",
                "And power consumption limits scaling. UNIVAC uses 125 kilowatts. A machine ten times larger would need 1.25 megawatts‚Äîa small power plant. Vacuum tubes simply can't scale to the computers we dream of."
              ],
              "dialogues": [
                {
                  "speaker": "Engineer",
                  "text": "We've hit a wall. To make computers faster, we need more tubes. More tubes mean more heat, more power, more failures. At some point, the machine spends more time broken than running."
                },
                {
                  "speaker": "You",
                  "text": "Is there no alternative?"
                },
                {
                  "speaker": "Engineer",
                  "text": "There's talk of something called a transistor. Solid-state switching‚Äîno vacuum, no filament, no heat. If it works, everything changes. But right now, it's a laboratory curiosity. We'll see."
                }
              ],
              "technicalNotes": [
                {
                  "content": "Vacuum tube reliability followed Poisson statistics: with n tubes each failing with probability p, the system failure rate is n√óp. UNIVAC's 5,200 tubes, even with 20,000-hour MTBF each, gave a system MTBF of only 4 hours. This 'tyranny of numbers' made scaling impossible without a new technology.",
                  "codeSnippet": "// Vacuum tube scaling problem\n// \n// Tube MTBF: 20,000 hours (best case)\n// \n// System MTBF = Tube MTBF / Number of tubes\n// \n// UNIVAC (5,200 tubes):\n//   20,000 / 5,200 = 3.8 hours\n// \n// 10√ó larger (52,000 tubes):\n//   20,000 / 52,000 = 0.4 hours\n//   = 23 minutes between failures!\n// \n// Conclusion: Vacuum tubes don't scale"
                }
              ],
              "nextScene": "scene-2-3-4"
            },
            {
              "id": "scene-2-3-4",
              "type": "challenge",
              "setting": {
                "text": "The UNIVAC console awaits. Magnetic tape drives hum. The operator's typewriter stands ready for commands."
              },
              "narrative": [
                "Experience the pinnacle of vacuum tube computing. UNIVAC combines everything learned from ENIAC and EDVAC: stored programs, mercury delay-line memory, magnetic tape I/O, and a complete instruction set.",
                "But this is also the end of an era. The next revolution‚Äîsolid-state electronics‚Äîis already brewing at Bell Labs."
              ],
              "challenge": {
                "title": "OPERATE THE UNIVAC",
                "objectives": [
                  { "id": "obj-1", "text": "Load a program from magnetic tape", "completed": false },
                  { "id": "obj-2", "text": "Set initial values in memory", "completed": false },
                  { "id": "obj-3", "text": "Execute the program", "completed": false },
                  { "id": "obj-4", "text": "Interpret the output", "completed": false },
                  { "id": "obj-5", "text": "Debug a simple error", "completed": false }
                ]
              },
              "technicalNotes": [
                {
                  "content": "UNIVAC operators interacted through a supervisory typewriter and console switches. Programs were loaded from magnetic tape‚Äîa revolutionary storage medium that replaced punch cards. A single tape reel held more data than 60,000 punch cards.",
                  "codeSnippet": "// UNIVAC I programming\n// Instructions: 44 basic operations\n// Word size: 12 characters (72 bits)\n// Memory addressing: 0-999 decimal\n// \n// Sample instruction types:\n// A  (Add)\n// S  (Subtract)\n// M  (Multiply)\n// D  (Divide)\n// B  (Branch)\n// U  (Unconditional transfer)"
                }
              ],
              "nextScene": "scene-2-3-5"
            },
            {
              "id": "scene-2-3-5",
              "type": "dialogue",
              "setting": {
                "text": "The UNIVAC hums steadily, its tubes glowing orange. But in the corner, a small device sits in a glass case: a transistor from Bell Labs. The future in miniature."
              },
              "dialogues": [
                {
                  "speaker": "Eckert",
                  "text": "We've pushed vacuum tubes as far as they can go. UNIVAC II will be faster, more reliable‚Äîbut still hot, still power-hungry, still fragile."
                },
                {
                  "speaker": "You",
                  "text": "What about that transistor I keep hearing about? Solid-state switching?"
                },
                {
                  "speaker": "Eckert",
                  "text": "The transistor? It's promising, but unproven at scale. Can you build a computer from thousands of transistors? Can they be made reliably enough? We'll see."
                },
                {
                  "speaker": "Mauchly",
                  "text": "If transistors work... if they really work at scale... everything changes. No heat. No vacuum. A computer that fits on a desk instead of filling a room."
                }
              ],
              "narrative": [
                "The vacuum tube era reached its zenith with UNIVAC. These electronic giants proved that computers could be useful, reliable, and commercially successful.",
                "But they were giants‚Äîmassive, power-hungry, and expensive. The tubes that gave them speed also gave them their limitations: heat that required cooling systems, power bills that dwarfed salaries, and failure rates that demanded constant maintenance.",
                "The solution was already in hand. In 1947, at Bell Labs, Bardeen, Brattain, and Shockley had invented the transistor. Small, cool, reliable‚Äîeverything the vacuum tube was not.",
                "The solid-state revolution was about to begin.",
                "Continue to Act 3: The Solid State Revolution."
              ]
            }
          ]
        }
      ]
    }
  ]
}
