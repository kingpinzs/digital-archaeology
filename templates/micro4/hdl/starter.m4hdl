<<<<<<< HEAD
# ============================================================
# MICRO4 CPU STARTER TEMPLATE
# ============================================================
# Welcome! This is your starting point for building a 4-bit CPU.
#
# WHAT'S PROVIDED (working):
#   - Program Counter (PC) - 8 bits, tracks current instruction
#   - Accumulator (A) - 4 bits, your working register
#   - Zero Flag (Z) - 1 bit, set when result is zero
#   - Instruction Register (IR) - 8 bits, holds current instruction
#   - Memory Address Register (MAR) - 8 bits, holds memory address
#   - Memory Data Register (MDR) - 4 bits, holds data to/from memory
#   - Basic instruction decoder for opcode extraction
#   - Memory interface (read/write wiring)
#
# YOUR TASK (marked with TODO):
#   - Complete the ALU (currently just passes data through)
#   - Implement ADD operation
#   - Implement SUB operation
#   - Add AND/OR/XOR operations (optional challenge)
#   - Complete conditional jump logic (JZ instruction)
#
# TESTING:
#   - NOP behavior works (do nothing, advance PC)
#   - LDI (Load Immediate) works - loads 4-bit value into A
#   - LDA (Load from Address) works - loads from memory into A
#   - STA (Store to Address) works - stores A to memory
#   - ADD, SUB, JZ need YOUR implementation
#
# INSTRUCTION SET:
#   0x0 = HLT (halt)        0x4 = SUB addr (A = A - mem[addr])
#   0x1 = LDA addr          0x5 = JMP addr (unconditional jump)
#   0x2 = STA addr          0x6 = JZ addr (jump if zero)
#   0x3 = ADD addr          0x7 = LDI n (load immediate 4-bit)
#
# ============================================================

# ============================================================
# SECTION 1: CLOCK AND CONTROL SIGNALS
# ============================================================
# These are the master timing and control signals for the CPU.

wire clk;           # Master clock - everything happens on clock edges
wire rst;           # Reset signal - when high, CPU resets to initial state
wire halt;          # Halt signal - stops the CPU when HLT instruction runs

# ============================================================
# SECTION 2: PROGRAM COUNTER (PROVIDED - WORKING)
# ============================================================
# The PC holds the address of the NEXT instruction to fetch.
# It starts at 0x00 and increments after each instruction.
# Jump instructions can load a new value into PC.
#
# PC is 8 bits wide, allowing addresses 0x00 to 0xFF (256 locations)

wire [7:0] pc;          # Current program counter value
wire [7:0] pc_next;     # Next value for PC (computed combinationally)
wire pc_load;           # When high, load pc_next into PC
wire pc_inc;            # When high, increment PC by 1
wire pc_inc2;           # When high, increment PC by 2 (2-byte instructions)

# PC Register (8 D flip-flops with reset)
# On reset: PC = 0x00
# On clock edge: PC = pc_next
dff PC0 (input: pc_next[0] clk rst, output: pc[0]);
dff PC1 (input: pc_next[1] clk rst, output: pc[1]);
dff PC2 (input: pc_next[2] clk rst, output: pc[2]);
dff PC3 (input: pc_next[3] clk rst, output: pc[3]);
dff PC4 (input: pc_next[4] clk rst, output: pc[4]);
dff PC5 (input: pc_next[5] clk rst, output: pc[5]);
dff PC6 (input: pc_next[6] clk rst, output: pc[6]);
dff PC7 (input: pc_next[7] clk rst, output: pc[7]);

# ============================================================
# SECTION 3: ACCUMULATOR REGISTER (PROVIDED - WORKING)
# ============================================================
# The Accumulator (A) is your main working register.
# All arithmetic operations use A as both source and destination.
# Example: ADD loads mem[addr], computes A + mem[addr], stores in A
#
# A is 4 bits wide (this is a 4-bit CPU after all!)

wire [3:0] acc;         # Current accumulator value
wire [3:0] acc_next;    # Next value for accumulator
wire acc_load;          # When high, load acc_next into accumulator

# Accumulator Register (4 D flip-flops with reset)
dff ACC0 (input: acc_next[0] clk rst, output: acc[0]);
dff ACC1 (input: acc_next[1] clk rst, output: acc[1]);
dff ACC2 (input: acc_next[2] clk rst, output: acc[2]);
dff ACC3 (input: acc_next[3] clk rst, output: acc[3]);

# ============================================================
# SECTION 4: ZERO FLAG (PROVIDED - WORKING)
# ============================================================
# The Zero flag (Z) is set when an operation produces a zero result.
# Used by JZ (Jump if Zero) for conditional branching.
#
# Z = 1 when accumulator contains 0000
# Z = 0 otherwise

wire z_flag;            # Current zero flag value
wire z_flag_next;       # Next value for zero flag
wire z_load;            # When high, update zero flag

# Zero Flag Register (1 D flip-flop with reset)
dff ZFLAG (input: z_flag_next clk rst, output: z_flag);

# Zero detection logic: Z = 1 when acc == 0000
# This is a NOR of all accumulator bits
wire acc_or_01, acc_or_23, acc_or_all;
or  Z_OR01 (input: acc[0] acc[1], output: acc_or_01);
or  Z_OR23 (input: acc[2] acc[3], output: acc_or_23);
or  Z_OR_ALL (input: acc_or_01 acc_or_23, output: acc_or_all);
not Z_NOT (input: acc_or_all, output: z_flag_next);

# ============================================================
# SECTION 5: INSTRUCTION REGISTER (PROVIDED - WORKING)
# ============================================================
# The IR holds the current instruction being executed.
# Format: [OPCODE 7:4][OPERAND 3:0]
#   - Upper nibble (bits 7-4): opcode (which instruction)
#   - Lower nibble (bits 3-0): immediate operand (for LDI)
#
# For 2-byte instructions (LDA, STA, ADD, SUB, JMP, JZ),
# the full 8-bit address comes from the next byte in memory.

wire [7:0] ir;          # Instruction register
wire ir_load;           # When high, load new instruction

# Instruction Register (8 D flip-flops)
dff IR0 (input: ir_next[0] clk rst, output: ir[0]);
dff IR1 (input: ir_next[1] clk rst, output: ir[1]);
dff IR2 (input: ir_next[2] clk rst, output: ir[2]);
dff IR3 (input: ir_next[3] clk rst, output: ir[3]);
dff IR4 (input: ir_next[4] clk rst, output: ir[4]);
dff IR5 (input: ir_next[5] clk rst, output: ir[5]);
dff IR6 (input: ir_next[6] clk rst, output: ir[6]);
dff IR7 (input: ir_next[7] clk rst, output: ir[7]);

wire [7:0] ir_next;     # Next value for IR (from memory)

# ============================================================
# SECTION 6: MEMORY INTERFACE (PROVIDED - WORKING)
# ============================================================
# Memory Address Register (MAR): holds address for memory access
# Memory Data Register (MDR): holds data to/from memory
#
# To READ memory:
#   1. Put address in MAR
#   2. Assert mem_read
#   3. MDR receives data from memory
#
# To WRITE memory:
#   1. Put address in MAR
#   2. Put data in MDR (from accumulator)
#   3. Assert mem_write

wire [7:0] mar;         # Memory address register
wire mar_load;          # When high, load address into MAR
wire [3:0] mdr;         # Memory data register
wire mdr_load;          # When high, load data into MDR

# Memory control signals
wire mem_read;          # Assert to read from memory
wire mem_write;         # Assert to write to memory

# External memory interface
wire [7:0] mem_addr;    # Address bus to memory
wire [3:0] mem_data_in; # Data bus from memory (read)
wire [3:0] mem_data_out;# Data bus to memory (write)

# MAR Register (8 D flip-flops)
dff MAR0 (input: mar_next[0] clk rst, output: mar[0]);
dff MAR1 (input: mar_next[1] clk rst, output: mar[1]);
dff MAR2 (input: mar_next[2] clk rst, output: mar[2]);
dff MAR3 (input: mar_next[3] clk rst, output: mar[3]);
dff MAR4 (input: mar_next[4] clk rst, output: mar[4]);
dff MAR5 (input: mar_next[5] clk rst, output: mar[5]);
dff MAR6 (input: mar_next[6] clk rst, output: mar[6]);
dff MAR7 (input: mar_next[7] clk rst, output: mar[7]);

wire [7:0] mar_next;    # Next value for MAR

# MDR Register (4 D flip-flops)
dff MDR0 (input: mdr_next[0] clk rst, output: mdr[0]);
dff MDR1 (input: mdr_next[1] clk rst, output: mdr[1]);
dff MDR2 (input: mdr_next[2] clk rst, output: mdr[2]);
dff MDR3 (input: mdr_next[3] clk rst, output: mdr[3]);

wire [3:0] mdr_next;    # Next value for MDR

# Connect MAR to memory address bus
=======
# ============================================
# Micro4 CPU - STARTER TEMPLATE
# ============================================
# Welcome! This is a partially complete 4-bit CPU.
# Your job is to complete the TODO sections.
#
# What's already working:
#   - Program Counter (8-bit)
#   - Accumulator Register (4-bit)
#   - Zero Flag (1-bit)
#   - Instruction Register (8-bit)
#   - Memory Address Register (8-bit)
#   - Memory Data Register (4-bit)
#   - Memory interface (read/write)
#   - Instruction fetch logic
#   - HLT instruction
#   - LDI instruction (load immediate)
#
# What YOU need to complete (marked with TODO):
#   - ADD operation in ALU
#   - SUB operation in ALU
#   - LDA instruction (load from memory)
#   - STA instruction (store to memory)
#   - JMP instruction (unconditional jump)
#   - JZ instruction (jump if zero)
#   - [BONUS] AND, OR, XOR operations
#
# Architecture:
#   - 4-bit data bus
#   - 8-bit address bus (256 nibble locations)
#   - Accumulator-based (single working register)
#   - 8 basic instructions (opcodes 0-7)

# ============================================
# CPU Block Diagram
# ============================================
#
#  +------------------------------------------------------------------+
#  |                         MICRO4 CPU                               |
#  |                                                                  |
#  |   +--------+    +--------+    +--------+                        |
#  |   |   PC   |    |   IR   |    |   A    |                        |
#  |   | 8-bit  |    | 8-bit  |    | 4-bit  |                        |
#  |   +---+----+    +---+----+    +---+----+                        |
#  |       |             |             |                              |
#  |       v             v             v                              |
#  |   +--------+    +--------+    +--------+                        |
#  |   |  MAR   |    | DECODE |    |  ALU   |  <-- YOUR WORK HERE    |
#  |   | 8-bit  |    |        |    | 4-bit  |                        |
#  |   +---+----+    +---+----+    +---+----+                        |
#  |       |             |             |                              |
#  |       v             v             v                              |
#  |   +--------+    +--------+    +--------+                        |
#  |   |  MDR   |<-->|CONTROL |    |   Z    |                        |
#  |   | 4-bit  |    | UNIT   |    |  flag  |                        |
#  |   +---+----+    +--------+    +--------+                        |
#  |       |                                                          |
#  +-------+----------------------------------------------------------+
#          |
#          v
#      MEMORY BUS

# ============================================
# Clock and Reset Signals
# ============================================
wire clk;           # System clock
wire rst;           # Reset signal (active high)

# ============================================
# Program Counter (8-bit) - COMPLETE
# ============================================
# The PC holds the address of the next instruction to fetch.
# Operations:
#   - Reset to 0x00
#   - Increment by 1 (pc_inc)
#   - Increment by 2 (pc_inc2, for 2-byte instructions)
#   - Load new value (pc_load, for jumps)

wire [7:0] pc;          # Current PC value
wire [7:0] pc_next;     # Next PC value (after increment)
wire pc_load;           # Load signal for jumps
wire pc_inc;            # Increment by 1
wire pc_inc2;           # Increment by 2

# PC implemented as 8 D flip-flops
dff PC0 (input: pc_next[0] clk, output: pc[0]);
dff PC1 (input: pc_next[1] clk, output: pc[1]);
dff PC2 (input: pc_next[2] clk, output: pc[2]);
dff PC3 (input: pc_next[3] clk, output: pc[3]);
dff PC4 (input: pc_next[4] clk, output: pc[4]);
dff PC5 (input: pc_next[5] clk, output: pc[5]);
dff PC6 (input: pc_next[6] clk, output: pc[6]);
dff PC7 (input: pc_next[7] clk, output: pc[7]);

# ============================================
# Accumulator (4-bit) - COMPLETE
# ============================================
# The accumulator is the main working register.
# All arithmetic operations use it as one operand
# and store the result back in it.

wire [3:0] acc;         # Current accumulator value
wire [3:0] acc_next;    # Next value to load
wire acc_load;          # Enable loading new value

# Accumulator implemented as 4 D flip-flops with load enable
# MUX: if acc_load, use acc_next; else keep acc
wire acc_loadn;
not ACC_LOADN (input: acc_load, output: acc_loadn);

# Bit 0
wire acc_hold_0, acc_new_0, acc_d_0;
and ACC_HOLD0 (input: acc[0] acc_loadn, output: acc_hold_0);
and ACC_NEW0 (input: acc_next[0] acc_load, output: acc_new_0);
or  ACC_MUX0 (input: acc_hold_0 acc_new_0, output: acc_d_0);
dff ACC0 (input: acc_d_0 clk, output: acc[0]);

# Bit 1
wire acc_hold_1, acc_new_1, acc_d_1;
and ACC_HOLD1 (input: acc[1] acc_loadn, output: acc_hold_1);
and ACC_NEW1 (input: acc_next[1] acc_load, output: acc_new_1);
or  ACC_MUX1 (input: acc_hold_1 acc_new_1, output: acc_d_1);
dff ACC1 (input: acc_d_1 clk, output: acc[1]);

# Bit 2
wire acc_hold_2, acc_new_2, acc_d_2;
and ACC_HOLD2 (input: acc[2] acc_loadn, output: acc_hold_2);
and ACC_NEW2 (input: acc_next[2] acc_load, output: acc_new_2);
or  ACC_MUX2 (input: acc_hold_2 acc_new_2, output: acc_d_2);
dff ACC2 (input: acc_d_2 clk, output: acc[2]);

# Bit 3
wire acc_hold_3, acc_new_3, acc_d_3;
and ACC_HOLD3 (input: acc[3] acc_loadn, output: acc_hold_3);
and ACC_NEW3 (input: acc_next[3] acc_load, output: acc_new_3);
or  ACC_MUX3 (input: acc_hold_3 acc_new_3, output: acc_d_3);
dff ACC3 (input: acc_d_3 clk, output: acc[3]);

# ============================================
# Zero Flag (1-bit) - COMPLETE
# ============================================
# Set when the accumulator becomes zero.
# Used by the JZ (jump if zero) instruction.

wire z_flag;            # Current zero flag value
wire z_flag_next;       # Next zero flag value
wire z_load;            # Enable loading zero flag

# Zero flag with load enable
wire z_hold, z_new, z_d;
wire z_loadn;
not Z_LOADN (input: z_load, output: z_loadn);
and Z_HOLD (input: z_flag z_loadn, output: z_hold);
and Z_NEW (input: z_flag_next z_load, output: z_new);
or  Z_MUX (input: z_hold z_new, output: z_d);
dff ZFLAG (input: z_d clk, output: z_flag);

# ============================================
# Instruction Register (8-bit) - COMPLETE
# ============================================
# Holds the current instruction being executed.
# Upper nibble [7:4] = opcode
# Lower nibble [3:0] = operand (for immediate instructions)

wire [7:0] ir;          # Current instruction
wire ir_load;           # Load new instruction

# IR as 8 D flip-flops (simplified - always loads)
dff IR0 (input: ir[0] clk, output: ir[0]);
dff IR1 (input: ir[1] clk, output: ir[1]);
dff IR2 (input: ir[2] clk, output: ir[2]);
dff IR3 (input: ir[3] clk, output: ir[3]);
dff IR4 (input: ir[4] clk, output: ir[4]);
dff IR5 (input: ir[5] clk, output: ir[5]);
dff IR6 (input: ir[6] clk, output: ir[6]);
dff IR7 (input: ir[7] clk, output: ir[7]);

# ============================================
# Memory Address Register (8-bit) - COMPLETE
# ============================================
# Holds the address for memory operations.

wire [7:0] mar;         # Memory address
wire mar_load;          # Load new address

# MAR as 8 D flip-flops (simplified)
dff MAR0 (input: mar[0] clk, output: mar[0]);
dff MAR1 (input: mar[1] clk, output: mar[1]);
dff MAR2 (input: mar[2] clk, output: mar[2]);
dff MAR3 (input: mar[3] clk, output: mar[3]);
dff MAR4 (input: mar[4] clk, output: mar[4]);
dff MAR5 (input: mar[5] clk, output: mar[5]);
dff MAR6 (input: mar[6] clk, output: mar[6]);
dff MAR7 (input: mar[7] clk, output: mar[7]);

# ============================================
# Memory Data Register (4-bit) - COMPLETE
# ============================================
# Holds data read from or to be written to memory.

wire [3:0] mdr;         # Memory data
wire mdr_load;          # Load new data

# MDR as 4 D flip-flops (simplified)
dff MDR0 (input: mdr[0] clk, output: mdr[0]);
dff MDR1 (input: mdr[1] clk, output: mdr[1]);
dff MDR2 (input: mdr[2] clk, output: mdr[2]);
dff MDR3 (input: mdr[3] clk, output: mdr[3]);

# ============================================
# Instruction Decoder - COMPLETE
# ============================================
# Decodes the opcode to determine which instruction to execute.
#
# Opcodes (upper nibble of IR):
#   0x0 = HLT   - Halt execution
#   0x1 = LDA   - Load accumulator from memory
#   0x2 = STA   - Store accumulator to memory
#   0x3 = ADD   - Add memory to accumulator
#   0x4 = SUB   - Subtract memory from accumulator
#   0x5 = JMP   - Unconditional jump
#   0x6 = JZ    - Jump if zero flag is set
#   0x7 = LDI   - Load immediate value into accumulator

wire [3:0] opcode;      # Extracted opcode
wire is_hlt;            # Decoded: HLT instruction
wire is_lda;            # Decoded: LDA instruction
wire is_sta;            # Decoded: STA instruction
wire is_add;            # Decoded: ADD instruction
wire is_sub;            # Decoded: SUB instruction
wire is_jmp;            # Decoded: JMP instruction
wire is_jz;             # Decoded: JZ instruction
wire is_ldi;            # Decoded: LDI instruction

# Extract opcode from IR upper nibble
buf DEC_OP0 (input: ir[4], output: opcode[0]);
buf DEC_OP1 (input: ir[5], output: opcode[1]);
buf DEC_OP2 (input: ir[6], output: opcode[2]);
buf DEC_OP3 (input: ir[7], output: opcode[3]);

# Decode logic - creates inverted opcode bits for matching
wire op0n, op1n, op2n, op3n;
not DEC_NOT0 (input: opcode[0], output: op0n);
not DEC_NOT1 (input: opcode[1], output: op1n);
not DEC_NOT2 (input: opcode[2], output: op2n);
not DEC_NOT3 (input: opcode[3], output: op3n);

# HLT: opcode = 0000
# is_hlt = !op3 & !op2 & !op1 & !op0
wire hlt_t1, hlt_t2;
and DEC_HLT1 (input: op3n op2n, output: hlt_t1);
and DEC_HLT2 (input: op1n op0n, output: hlt_t2);
and DEC_HLT3 (input: hlt_t1 hlt_t2, output: is_hlt);

# LDA: opcode = 0001
# is_lda = !op3 & !op2 & !op1 & op0
wire lda_t;
and DEC_LDA1 (input: hlt_t1 op1n, output: lda_t);
and DEC_LDA2 (input: lda_t opcode[0], output: is_lda);

# STA: opcode = 0010
# is_sta = !op3 & !op2 & op1 & !op0
wire sta_t1, sta_t2;
and DEC_STA1 (input: op3n op2n, output: sta_t1);
and DEC_STA2 (input: opcode[1] op0n, output: sta_t2);
and DEC_STA3 (input: sta_t1 sta_t2, output: is_sta);

# ADD: opcode = 0011
# is_add = !op3 & !op2 & op1 & op0
wire add_t;
and DEC_ADD1 (input: opcode[1] opcode[0], output: add_t);
and DEC_ADD2 (input: sta_t1 add_t, output: is_add);

# SUB: opcode = 0100
# is_sub = !op3 & op2 & !op1 & !op0
wire sub_t1, sub_t2;
and DEC_SUB1 (input: op3n opcode[2], output: sub_t1);
and DEC_SUB2 (input: op1n op0n, output: sub_t2);
and DEC_SUB3 (input: sub_t1 sub_t2, output: is_sub);

# JMP: opcode = 0101
# is_jmp = !op3 & op2 & !op1 & op0
wire jmp_t;
and DEC_JMP1 (input: op1n opcode[0], output: jmp_t);
and DEC_JMP2 (input: sub_t1 jmp_t, output: is_jmp);

# JZ: opcode = 0110
# is_jz = !op3 & op2 & op1 & !op0
wire jz_t;
and DEC_JZ1 (input: opcode[1] op0n, output: jz_t);
and DEC_JZ2 (input: sub_t1 jz_t, output: is_jz);

# LDI: opcode = 0111
# is_ldi = !op3 & op2 & op1 & op0
wire ldi_t;
and DEC_LDI1 (input: opcode[1] opcode[0], output: ldi_t);
and DEC_LDI2 (input: sub_t1 ldi_t, output: is_ldi);

# ============================================
# Memory Interface - COMPLETE
# ============================================
# Connects the CPU to external memory.

wire [7:0] mem_addr;    # Address to memory
wire [3:0] mem_data_in; # Data from memory
wire [3:0] mem_data_out;# Data to memory
wire mem_read;          # Read enable
wire mem_write;         # Write enable

# MAR drives memory address
>>>>>>> e0a7015c6d758cbc4977678e4b8043c68e2e1700
buf MEM_ADDR0 (input: mar[0], output: mem_addr[0]);
buf MEM_ADDR1 (input: mar[1], output: mem_addr[1]);
buf MEM_ADDR2 (input: mar[2], output: mem_addr[2]);
buf MEM_ADDR3 (input: mar[3], output: mem_addr[3]);
buf MEM_ADDR4 (input: mar[4], output: mem_addr[4]);
buf MEM_ADDR5 (input: mar[5], output: mem_addr[5]);
buf MEM_ADDR6 (input: mar[6], output: mem_addr[6]);
buf MEM_ADDR7 (input: mar[7], output: mem_addr[7]);

<<<<<<< HEAD
# Connect accumulator to memory data output (for STA instruction)
=======
# Accumulator drives data output (for STA)
>>>>>>> e0a7015c6d758cbc4977678e4b8043c68e2e1700
buf MEM_DOUT0 (input: acc[0], output: mem_data_out[0]);
buf MEM_DOUT1 (input: acc[1], output: mem_data_out[1]);
buf MEM_DOUT2 (input: acc[2], output: mem_data_out[2]);
buf MEM_DOUT3 (input: acc[3], output: mem_data_out[3]);

<<<<<<< HEAD
# ============================================================
# SECTION 7: INSTRUCTION DECODER (PROVIDED - WORKING)
# ============================================================
# The decoder extracts the opcode from IR[7:4] and generates
# individual instruction signals (is_hlt, is_lda, etc.)
#
# Opcodes:
#   0000 (0x0) = HLT    0100 (0x4) = SUB
#   0001 (0x1) = LDA    0101 (0x5) = JMP
#   0010 (0x2) = STA    0110 (0x6) = JZ
#   0011 (0x3) = ADD    0111 (0x7) = LDI

wire [3:0] opcode;      # Extracted opcode from IR[7:4]
wire is_hlt;            # Decoded: is this HLT instruction?
wire is_lda;            # Decoded: is this LDA instruction?
wire is_sta;            # Decoded: is this STA instruction?
wire is_add;            # Decoded: is this ADD instruction?
wire is_sub;            # Decoded: is this SUB instruction?
wire is_jmp;            # Decoded: is this JMP instruction?
wire is_jz;             # Decoded: is this JZ instruction?
wire is_ldi;            # Decoded: is this LDI instruction?

# Extract opcode from IR upper nibble
buf DEC_OP0 (input: ir[4], output: opcode[0]);
buf DEC_OP1 (input: ir[5], output: opcode[1]);
buf DEC_OP2 (input: ir[6], output: opcode[2]);
buf DEC_OP3 (input: ir[7], output: opcode[3]);

# Inverted opcode bits (needed for decoding)
wire op0n, op1n, op2n, op3n;
not DEC_NOT0 (input: opcode[0], output: op0n);
not DEC_NOT1 (input: opcode[1], output: op1n);
not DEC_NOT2 (input: opcode[2], output: op2n);
not DEC_NOT3 (input: opcode[3], output: op3n);

# HLT = 0000: !op3 & !op2 & !op1 & !op0
wire hlt_t1, hlt_t2;
and DEC_HLT1 (input: op3n op2n, output: hlt_t1);
and DEC_HLT2 (input: op1n op0n, output: hlt_t2);
and DEC_HLT3 (input: hlt_t1 hlt_t2, output: is_hlt);

# LDA = 0001: !op3 & !op2 & !op1 & op0
wire lda_t;
and DEC_LDA1 (input: hlt_t1 op1n, output: lda_t);
and DEC_LDA2 (input: lda_t opcode[0], output: is_lda);

# STA = 0010: !op3 & !op2 & op1 & !op0
wire sta_t1, sta_t2;
and DEC_STA1 (input: op3n op2n, output: sta_t1);
and DEC_STA2 (input: opcode[1] op0n, output: sta_t2);
and DEC_STA3 (input: sta_t1 sta_t2, output: is_sta);

# ADD = 0011: !op3 & !op2 & op1 & op0
wire add_t;
and DEC_ADD1 (input: opcode[1] opcode[0], output: add_t);
and DEC_ADD2 (input: sta_t1 add_t, output: is_add);

# SUB = 0100: !op3 & op2 & !op1 & !op0
wire sub_t1, sub_t2;
and DEC_SUB1 (input: op3n opcode[2], output: sub_t1);
and DEC_SUB2 (input: op1n op0n, output: sub_t2);
and DEC_SUB3 (input: sub_t1 sub_t2, output: is_sub);

# JMP = 0101: !op3 & op2 & !op1 & op0
wire jmp_t;
and DEC_JMP1 (input: op1n opcode[0], output: jmp_t);
and DEC_JMP2 (input: sub_t1 jmp_t, output: is_jmp);

# JZ = 0110: !op3 & op2 & op1 & !op0
wire jz_t;
and DEC_JZ1 (input: opcode[1] op0n, output: jz_t);
and DEC_JZ2 (input: sub_t1 jz_t, output: is_jz);

# LDI = 0111: !op3 & op2 & op1 & op0
wire ldi_t;
and DEC_LDI1 (input: opcode[1] opcode[0], output: ldi_t);
and DEC_LDI2 (input: sub_t1 ldi_t, output: is_ldi);

# ============================================================
# SECTION 8: CONTROL UNIT STATE MACHINE (PROVIDED - BASIC)
# ============================================================
# The control unit sequences through states to execute instructions.
# Each instruction takes multiple clock cycles.
#
# Basic states:
#   S0 = FETCH: Get instruction from memory at PC
#   S1 = DECODE: Figure out what instruction it is
#   S2 = EXECUTE: Do the operation
#   S3-S7 = Additional states for multi-cycle operations

wire [2:0] state;       # Current state (0-7)
wire [2:0] state_next;  # Next state

# State register (3 D flip-flops)
dff STATE0 (input: state_next[0] clk rst, output: state[0]);
dff STATE1 (input: state_next[1] clk rst, output: state[1]);
dff STATE2 (input: state_next[2] clk rst, output: state[2]);

# ============================================================
# SECTION 9: ALU - ARITHMETIC LOGIC UNIT
# ============================================================
#
# !!! TODO: THIS IS YOUR MAIN TASK !!!
#
# The ALU performs arithmetic and logic operations.
# Currently it just passes input A through unchanged.
#
# ALU Inputs:
#   alu_a_in[3:0] = First operand (from accumulator)
#   alu_b_in[3:0] = Second operand (from memory via MDR)
#   alu_op[1:0]   = Operation select:
#                   00 = PASS (just output A, used for loads)
#                   01 = ADD  (A + B)
#                   10 = SUB  (A - B)
#                   11 = reserved (use for AND/OR/XOR challenge!)
#
# ALU Outputs:
#   alu_result[3:0] = Result of operation
#   alu_zero        = 1 if result is 0000
#   alu_carry       = Carry/borrow output (for multi-precision math)

wire [3:0] alu_a_in;    # ALU input A (from accumulator)
wire [3:0] alu_b_in;    # ALU input B (from MDR)
wire [1:0] alu_op;      # ALU operation select
wire [3:0] alu_result;  # ALU result
wire alu_zero;          # Zero flag output
wire alu_carry;         # Carry flag output

# Connect accumulator to ALU input A
buf ALU_A0 (input: acc[0], output: alu_a_in[0]);
buf ALU_A1 (input: acc[1], output: alu_a_in[1]);
buf ALU_A2 (input: acc[2], output: alu_a_in[2]);
buf ALU_A3 (input: acc[3], output: alu_a_in[3]);

# Connect MDR to ALU input B
buf ALU_B0 (input: mdr[0], output: alu_b_in[0]);
buf ALU_B1 (input: mdr[1], output: alu_b_in[1]);
buf ALU_B2 (input: mdr[2], output: alu_b_in[2]);
buf ALU_B3 (input: mdr[3], output: alu_b_in[3]);

# ALU operation select from instruction decoder
# is_sub sets alu_op[1], is_add sets alu_op[0]
buf ALU_OP0 (input: is_add, output: alu_op[0]);
buf ALU_OP1 (input: is_sub, output: alu_op[1]);

# ---------------------------------------------------------
# TODO: IMPLEMENT THE ALU
# ---------------------------------------------------------
# Current implementation: ALU just passes A through (no-op)
# This means LDA and LDI work, but ADD and SUB don't!
#
# Your task: Replace this pass-through with actual arithmetic.
#
# HINT 1: Start with a half-adder for single-bit addition
#         sum = a XOR b
#         carry = a AND b
#
# HINT 2: Chain half-adders into a full adder
#         Full adder adds three bits: a, b, carry_in
#         sum = a XOR b XOR carry_in
#         carry_out = (a AND b) OR (carry_in AND (a XOR b))
#
# HINT 3: For subtraction, use two's complement
#         A - B = A + (~B) + 1
#         Invert B and set carry_in to 1
#
# HINT 4: See hdl/03_alu.m4hdl for a complete ALU reference!

# PLACEHOLDER: ALU just passes A through (makes LDA/LDI work)
# DELETE THIS and implement real arithmetic!
buf ALU_PASS0 (input: alu_a_in[0], output: alu_result[0]);
buf ALU_PASS1 (input: alu_a_in[1], output: alu_result[1]);
buf ALU_PASS2 (input: alu_a_in[2], output: alu_result[2]);
buf ALU_PASS3 (input: alu_a_in[3], output: alu_result[3]);

# PLACEHOLDER: Carry is always 0 (needs real implementation)
# wire const_zero;
# buf ALU_CARRY_PLACEHOLDER (input: const_zero, output: alu_carry);

# Zero detection for ALU result
wire alu_or_01, alu_or_23, alu_or_all;
or ALU_Z_OR01 (input: alu_result[0] alu_result[1], output: alu_or_01);
or ALU_Z_OR23 (input: alu_result[2] alu_result[3], output: alu_or_23);
or ALU_Z_OR_ALL (input: alu_or_01 alu_or_23, output: alu_or_all);
not ALU_Z_NOT (input: alu_or_all, output: alu_zero);

# ---------------------------------------------------------
# END TODO: ALU IMPLEMENTATION
# ---------------------------------------------------------

# ============================================================
# SECTION 10: CONDITIONAL JUMP LOGIC
# ============================================================
#
# !!! TODO: COMPLETE THE JZ (JUMP IF ZERO) LOGIC !!!
#
# JZ should jump to the target address ONLY if the zero flag is set.
# Currently, JZ is wired the same as JMP (always jumps).
#
# Your task: Make JZ conditional on the zero flag.
#
# HINT: Use an AND gate
#       take_jz = is_jz AND z_flag
#       The PC should load the new address only when take_jz is true.

wire take_jump;         # Should we take this jump?

# JMP always jumps
# JZ should only jump if z_flag is set

# PLACEHOLDER: Currently JZ always jumps (incorrect!)
# TODO: Fix this so JZ only jumps when z_flag == 1
wire jz_taken;
and JZ_COND (input: is_jz z_flag, output: jz_taken);  # JZ: only if zero

# Combine jump signals: take jump if JMP or (JZ and zero flag)
or TAKE_JUMP (input: is_jmp jz_taken, output: take_jump);

# ============================================================
# SECTION 11: CONTROL SIGNAL GENERATION (PROVIDED - BASIC)
# ============================================================
# These signals control data flow through the CPU.
# They're generated based on the current state and instruction.

wire alu_to_acc;        # Route ALU result to accumulator
wire mdr_to_acc;        # Route MDR to accumulator (for LDA)
wire imm_to_acc;        # Route immediate to accumulator (for LDI)

# ============================================================
# COMPONENT COUNT SUMMARY
# ============================================================
#
# Registers (provided):
#   PC (8-bit):        8 DFFs
#   Accumulator:       4 DFFs
#   Zero Flag:         1 DFF
#   IR (8-bit):        8 DFFs
#   MAR (8-bit):       8 DFFs
#   MDR (4-bit):       4 DFFs
#   State (3-bit):     3 DFFs
#   --------------------------
#   Total:            36 DFFs
#
# Decoder (provided): ~50 gates
#
# ALU (TODO):         ~50-100 gates (your implementation!)
#
# Control Logic:      ~100 gates
#
# Estimated total when complete: ~400-500 gates
# (Compare to Intel 4004: ~2,300 transistors)

# ============================================================
# HOMEWORK CHALLENGES (after completing basic ALU)
# ============================================================
#
# Challenge 1: Add AND operation (opcode 0x8)
#   result[i] = a[i] AND b[i]
#
# Challenge 2: Add OR operation (opcode 0x9)
#   result[i] = a[i] OR b[i]
#
# Challenge 3: Add XOR operation (opcode 0xA)
#   result[i] = a[i] XOR b[i]
#
# Challenge 4: Add INC operation (A = A + 1, opcode 0xB)
#   Hint: Set B = 0001 internally
#
# Challenge 5: Add DEC operation (A = A - 1, opcode 0xC)
#   Hint: Set B = 0001 internally, use subtraction
#
# Challenge 6: Add JNZ (Jump if Not Zero, opcode 0xD)
#   Hint: take_jnz = is_jnz AND NOT(z_flag)
#
# Challenge 7: Add CMP operation (compare without storing, opcode 0xE)
#   Hint: Do subtraction but don't write result to A, only set flags
#
# See hdl/04_micro4_cpu.m4hdl for reference implementations!
=======
# ============================================
# Control Signals - PARTIAL
# ============================================
# Generated by control unit based on state and opcode.

wire halt;              # Stop execution
wire alu_to_acc;        # ALU result goes to accumulator
wire mdr_to_acc;        # MDR goes to accumulator (for LDA)
wire imm_to_acc;        # Immediate value goes to accumulator (for LDI)

# ============================================
# State Machine (simplified) - COMPLETE
# ============================================
# Controls the fetch-decode-execute cycle.

wire [2:0] state;
wire [2:0] state_next;

dff STATE0 (input: state_next[0] clk, output: state[0]);
dff STATE1 (input: state_next[1] clk, output: state[1]);
dff STATE2 (input: state_next[2] clk, output: state[2]);

# ============================================
#                  ALU SECTION
# ============================================
# THIS IS WHERE YOUR WORK BEGINS!
#
# The ALU (Arithmetic Logic Unit) performs all computations.
# It takes two 4-bit inputs and produces a 4-bit result.
#
# ALU Inputs:
#   alu_a[3:0] = Accumulator value
#   alu_b[3:0] = MDR value (from memory)
#   alu_op[0]  = Operation select (0=ADD, 1=SUB)
#
# ALU Outputs:
#   alu_r[3:0] = Result
#   alu_z      = Zero flag (1 if result is 0000)
#   alu_c      = Carry flag (overflow)

wire [3:0] alu_a;       # First operand (from accumulator)
wire [3:0] alu_b;       # Second operand (from MDR)
wire [1:0] alu_op;      # Operation select
wire [3:0] alu_r;       # Result
wire alu_z;             # Zero flag output
wire alu_c;             # Carry flag output

# Connect accumulator to ALU input A
buf ALU_A0 (input: acc[0], output: alu_a[0]);
buf ALU_A1 (input: acc[1], output: alu_a[1]);
buf ALU_A2 (input: acc[2], output: alu_a[2]);
buf ALU_A3 (input: acc[3], output: alu_a[3]);

# Connect MDR to ALU input B
buf ALU_B0 (input: mdr[0], output: alu_b[0]);
buf ALU_B1 (input: mdr[1], output: alu_b[1]);
buf ALU_B2 (input: mdr[2], output: alu_b[2]);
buf ALU_B3 (input: mdr[3], output: alu_b[3]);

# ALU operation: SUB if is_sub, else ADD
buf ALU_OP0 (input: is_sub, output: alu_op[0]);

# ============================================
# TODO #1: ALU - B INVERTER (for subtraction)
# ============================================
# For subtraction, we use two's complement:
#   A - B = A + (~B) + 1
#
# When alu_op[0]=1 (SUB), we need to invert B
# When alu_op[0]=0 (ADD), we pass B through unchanged
#
# Hint: You need:
#   1. NOT gates to create inverted B
#   2. MUX to select between B and ~B based on alu_op[0]
#
# The pattern is (for each bit i):
#   alu_b_inv[i] = NOT(alu_b[i])
#   alu_b_adj[i] = (alu_b[i] AND NOT(alu_op[0])) OR (alu_b_inv[i] AND alu_op[0])

wire [3:0] alu_b_inv;   # Inverted B
wire [3:0] alu_b_adj;   # B or ~B based on operation
wire alu_cin;           # Carry in (1 for SUB, 0 for ADD)

# PLACEHOLDER: Currently just passes B through (no inversion)
# DELETE THIS AND IMPLEMENT PROPER B INVERTER/MUX
buf ALU_BADJ0_PLACEHOLDER (input: alu_b[0], output: alu_b_adj[0]);
buf ALU_BADJ1_PLACEHOLDER (input: alu_b[1], output: alu_b_adj[1]);
buf ALU_BADJ2_PLACEHOLDER (input: alu_b[2], output: alu_b_adj[2]);
buf ALU_BADJ3_PLACEHOLDER (input: alu_b[3], output: alu_b_adj[3]);

# PLACEHOLDER: Carry in is always 0 (only works for ADD)
# For SUB to work, carry in should be alu_op[0]
wire const_zero;
not ALU_CIN_PLACEHOLDER_T (input: const_zero, output: const_zero);  # Creates 0
buf ALU_CIN_PLACEHOLDER (input: const_zero, output: alu_cin);

# ============================================
# TODO #2: ALU - 4-BIT ADDER
# ============================================
# Implement a 4-bit ripple carry adder.
#
# A full adder has:
#   Inputs:  A, B, Cin
#   Outputs: Sum, Cout
#
# For each bit:
#   Sum  = A XOR B XOR Cin
#   Cout = (A AND B) OR (A AND Cin) OR (B AND Cin)
#        = (A AND B) OR ((A XOR B) AND Cin)
#
# Chain 4 full adders together:
#   FA0: alu_a[0] + alu_b_adj[0] + alu_cin     -> alu_r[0], c0
#   FA1: alu_a[1] + alu_b_adj[1] + c0          -> alu_r[1], c1
#   FA2: alu_a[2] + alu_b_adj[2] + c1          -> alu_r[2], c2
#   FA3: alu_a[3] + alu_b_adj[3] + c2          -> alu_r[3], alu_c

wire alu_c0, alu_c1, alu_c2;  # Internal carries

# PLACEHOLDER: Result is currently just 0000
# DELETE THIS AND IMPLEMENT THE 4-BIT ADDER
buf ALU_R0_PLACEHOLDER (input: const_zero, output: alu_r[0]);
buf ALU_R1_PLACEHOLDER (input: const_zero, output: alu_r[1]);
buf ALU_R2_PLACEHOLDER (input: const_zero, output: alu_r[2]);
buf ALU_R3_PLACEHOLDER (input: const_zero, output: alu_r[3]);
buf ALU_C_PLACEHOLDER (input: const_zero, output: alu_c);

# ============================================
# TODO #3: ALU - ZERO FLAG
# ============================================
# The zero flag should be HIGH when the result is 0000.
#
# Z = NOT(R[0] OR R[1] OR R[2] OR R[3])
#
# Hint: Use OR gates to combine result bits, then NOT

# PLACEHOLDER: Zero flag is always 0
# DELETE THIS AND IMPLEMENT PROPER ZERO FLAG
buf ALU_Z_PLACEHOLDER (input: const_zero, output: alu_z);

# ============================================
# TODO #4: IMPLEMENT ADDITIONAL INSTRUCTIONS
# ============================================
# Once your ALU works, you can implement:
#
# LDA addr - Load from memory to accumulator
#   1. Fetch address byte from memory
#   2. Set MAR to address
#   3. Read memory, put in MDR
#   4. Copy MDR to accumulator
#
# STA addr - Store accumulator to memory
#   1. Fetch address byte from memory
#   2. Set MAR to address
#   3. Write accumulator to memory
#
# JMP addr - Unconditional jump
#   1. Fetch address byte from memory
#   2. Load address into PC
#
# JZ addr - Jump if zero flag set
#   1. Fetch address byte from memory
#   2. If Z flag is 1, load address into PC
#   3. If Z flag is 0, continue to next instruction

# ============================================
# TODO #5 (BONUS): ADDITIONAL ALU OPERATIONS
# ============================================
# Extend the ALU to support bitwise operations:
#
# AND: result = A AND B
# OR:  result = A OR B
# XOR: result = A XOR B
#
# You'll need to:
#   1. Add more alu_op bits to select operations
#   2. Implement each operation with gates
#   3. Use a MUX to select between operation results
#   4. Update the instruction decoder for new opcodes

# ============================================
# Component Count (current placeholder state)
# ============================================
# Registers:
#   PC (8-bit):     8 DFFs = ~320 transistors
#   Accumulator:    4 DFFs = ~160 transistors
#   Zero Flag:      1 DFF  = ~40 transistors
#   IR (8-bit):     8 DFFs = ~320 transistors
#   MAR (8-bit):    8 DFFs = ~320 transistors
#   MDR (4-bit):    4 DFFs = ~160 transistors
#   State (3-bit):  3 DFFs = ~120 transistors
#
# ALU (when complete): ~200 transistors
# Decoder:             ~50 transistors
# Control Logic:       ~200 transistors
# Multiplexers:        ~300 transistors
#
# TOTAL: ~2,200 transistors
# (Intel 4004 had ~2,300 transistors - we're close!)

# ============================================
# Testing Your Implementation
# ============================================
# After completing the TODO sections, test with:
#
# 1. Basic ADD test (programs/add.asm):
#    - Load 5 into A (LDI 5 or LDA [addr])
#    - Add 3 (ADD [addr])
#    - Result should be 8
#
# 2. Basic SUB test:
#    - Load 7 into A
#    - Subtract 3
#    - Result should be 4
#
# 3. Zero flag test:
#    - Load 5 into A
#    - Subtract 5
#    - Z flag should be 1
#    - JZ should take the jump
#
# 4. Loop test (countdown):
#    - Start at 5
#    - Subtract 1 in loop
#    - JZ to exit when zero
#    - Should iterate 5 times

# ============================================
# Reference: Full ALU Implementation
# ============================================
# If you get stuck, look at:
#   hdl/03_alu.m4hdl     - Complete ALU implementation
#   hdl/04_micro4_cpu.m4hdl - Complete CPU implementation
#
# But try to implement it yourself first!
# Understanding comes from building, not copying.
>>>>>>> e0a7015c6d758cbc4977678e4b8043c68e2e1700
